<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.gmirror.org/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//cdn.bootcss.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css"><meta name="keywords" content="王雨峰, 博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2"><meta name="description" content="Alan Wang&apos;s personal blog."><meta property="og:type" content="website"><meta property="og:title" content="王雨峰的博客"><meta property="og:url" content="http://wangyufeng.org/page/2/index.html"><meta property="og:site_name" content="王雨峰的博客"><meta property="og:description" content="Alan Wang&apos;s personal blog."><meta name="twitter:card" content="summary"><meta name="twitter:title" content="王雨峰的博客"><meta name="twitter:description" content="Alan Wang&apos;s personal blog."><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"}}</script><link rel="canonical" href="http://wangyufeng.org/page/2/"><title>王雨峰的博客</title></head><body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="//schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">王雨峰的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">随便写点东西，为互联网贡献一些比特。</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于我</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">文章归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/04/12/first-commit-at-github/" itemprop="url">第一次在 Github 上贡献代码</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-04-12T13:29:59+08:00" content="2016-04-12">2016-04-12</time></span></div></header><div class="post-body" itemprop="articleBody"><p>如果想了解 Git 和 Github，推荐阅读<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">廖雪峰的 Git 教程</a>。</p><hr><p>好吧，其实我贡献的不是代码。是一个程序员在 Github 上发布的电子书，我为发布者更改了几个小错误。不过不管怎么说，这是我第一次在 Github 上正经给别人贡献东西。</p><p>电子书是 <a href="http://growth.phodal.com/" target="_blank" rel="external">Growth: 全栈增长工程师指南</a>，Github 地址是 <a href="https://github.com/phodal/growth-ebook/" target="_blank" rel="external">growth-ebook</a>。 谢谢 @小文学长 在朋友圈的分享。如果连接打不开，请看文章底部的连接。</p><p>发布者说：</p><blockquote><p>阅读过程中遇到语法错误、拼写错误、技术错误等等，不烦来个Pull Request，这样可以帮助到其他阅读这本电子书的童鞋。</p></blockquote><p>正好，我在阅读的过程中发现了一些大小写、错别字的问题，我干脆就提交一个 Pull Request.</p><p>##1. fork 项目</p><p>如果想为其他人的 Github 项目做贡献，需要先将他的项目 fork 一份到自己的 Github 账号。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-4-12/77361122.jpg" alt=""></p><p>就是最右边这个 Fork。</p><p>##2. clone 项目</p><p>然后将已经 fork 到<strong>自己账号下的项目</strong>克隆到本地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/wangyufeng0615/growth-ebook.git</div></pre></td></tr></table></figure><p>向我这次提交的这种小 BUG 修复，就没必要单独新建一个 branch.</p><p>于是我直接在源文件中修改了一些大小写，和错别字，例如</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-4-12/26774216.jpg" alt=""></p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-4-12/84647919.jpg" alt=""></p><p>诸如此类十处左右。</p><p>本地更新的方式就和单机使用 Git 一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;统一大小写, 更正错别字&quot;</div><div class="line">git push</div></pre></td></tr></table></figure><ol><li>我觉得 commit 的信息需要写详细一些，毕竟这些信息是要给所有人看的，类似于我们做大物实验，要填写台子上的”使用手册”。虽然我一次也没写过。</li><li>这个 push 是 push 到自己的主页中的项目。不是项目发起人的项目。</li></ol><p>##3. 发起 Pull Request</p><p>从<strong>自己的页面的该项目</strong>中点那个绿色的 New pull requrst.</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-4-12/4715713.jpg" alt=""></p><p>然后可以对比代码的不同、填写注释信息等。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-4-12/11253949.jpg" alt=""></p><p>再点”Create pull request”就可以了。如果项目管理员觉得你这个 pull request 没问题，就会把你的代码 merge 进项目。</p><p>这个作者速度很快，我还没截图他就把我的 pull request 给 merge 了。如图：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-4-12/87890627.jpg" alt=""></p><p>从图中可以看出，作者将我的 commit 合并到了主分支中，并对我表示了感谢~~~现在我就是这个开源项目的贡献者之一了。很惭愧，只是做了一点微小的贡献。</p><p>给开源项目做贡献，在大多数情况下都应该是没有直接的物质回报，但这种人与人之间真诚的感谢，大概也是回报的一种吧。</p><p>##4. 其他问题</p><p>如果我把那个人的项目 fork 到本地后，我还没改完呢，作者已经提交新的 commit 了，他的内容和我本地的内容发生了变化，怎么办？</p><p>需要用<code>git rebase</code>指令让本地内容和上游库同步。这个事情我这次没实践。</p><p>##5. 参考资料</p><ul><li>(<a href="http://blog.csdn.net/zhangdaiscott/article/details/17438153" target="_blank" rel="external">http://blog.csdn.net/zhangdaiscott/article/details/17438153</a>)</li><li>Growth: 全栈增长工程师指南(<a href="http://growth.phodal.com/" target="_blank" rel="external">http://growth.phodal.com/</a>)</li><li>Github: growth-ebook(<a href="https://github.com/phodal/growth-ebook/" target="_blank" rel="external">https://github.com/phodal/growth-ebook/</a>)</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/04/11/char-to-tchar/" itemprop="url">EasyX中的TCHAR转换</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-04-11T08:41:21+08:00" content="2016-04-11">2016-04-11</time></span></div></header><div class="post-body" itemprop="articleBody"><p>EasyX 库中的 <code>outtextxy()</code>函数只能接受<code>TCHAR</code>格式的参数。</p><p>提供几种用过的常用数据格式转<code>TCHAR</code>的方法，供参考。如果不行，不妨再用 Google。关键词：xxx to TCHAR.</p><p>ps. <code>wchar_t</code> 和 <code>TCHAR</code> 在EasyX的应用中是一个意思，用哪个都行。他们都是为了处理Unicode字符而存在的，在咱们的EasyX程序中就是为了处理中文，但是其他西文字符也得转成TCHAR。</p><hr><p>说明：</p><ul><li>源数据：source</li><li>转换后的数据：dest</li></ul><p>###先要包含头文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;tchar.h&gt;</div></pre></td></tr></table></figure><p></p><p>###直接输出TCHAR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">outtextxy(x, y,  _T(&quot;要输出的字符串&quot;));</div></pre></td></tr></table></figure><p>###string 转 TCHAR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//先包含头文件</div><div class="line">#include &lt;atlstr.h&gt;	</div><div class="line"></div><div class="line">_tcscpy_s(dest, CA2T(source.c_str()));</div></pre></td></tr></table></figure><h3 id="int-转-TCHAR"><a href="#int-转-TCHAR" class="headerlink" title="int 转 TCHAR"></a>int 转 TCHAR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_stprintf_s(dest, _T(&quot;%d&quot;), source);</div></pre></td></tr></table></figure><h3 id="char-转-TCHAR"><a href="#char-转-TCHAR" class="headerlink" title="char 转 TCHAR"></a>char 转 TCHAR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_stprintf_s(dest, _T(&quot;%c&quot;), source);</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MultiByteToWideChar(CP_ACP, 0, source, 20, dest, 20);</div><div class="line">//20是长度</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/04/07/c-switch/" itemprop="url">C 语言中为什么有 switch？ | 七系</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-04-07T18:30:02+08:00" content="2016-04-07">2016-04-07</time></span></div></header><div class="post-body" itemprop="articleBody"><p>如果文中有BUG，请留言反馈，谢谢~</p><hr><p>C语言中，有且仅有三种基本语句结构</p><ol><li>顺序结构</li><li>循环结构(<code>while</code>, <code>for</code>等)</li><li>条件结构</li></ol><p>其中，条件结构有<code>if-else</code>和<code>switch-case</code>两种。还有<code>三元运算符</code>，形如<code>a &gt; b ? c : d;</code>不常用。</p><p>经常地，<code>if-else</code>结构和<code>switch-case</code>结构可以相互转化。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">switch (day)</div><div class="line">&#123;</div><div class="line">    case &apos;1&apos; : printf(&quot;Monday\n&quot;);  break;</div><div class="line">    case &apos;2&apos; : printf(&quot;Tuesday\n&quot;); break;</div><div class="line">    case 1 : printf(&quot;1\n&quot;); break;	//注意1和&apos;1&apos;的区别</div><div class="line">    default : printf(&quot;error\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以转换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (day == &apos;1&apos;)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Monday\n&quot;);</div><div class="line">&#125; </div><div class="line">else if (day == &apos;2&apos;)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Tuesday\n&quot;);</div><div class="line">&#125; </div><div class="line">else if (day == 1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;1\n&quot;);</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    printf(&quot;error\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两者实现的功能是一样的。一般来说，<code>if-else</code>结构相对于<code>switch-case</code>结构来说更为灵活一些，比如，分支的条件可以是”一定范围”，但<code>switch-case</code>结构的条件变量必须是整数或字符，或枚举型。</p><hr><p>题外话：这里想强调的是，<code>switch-case</code>结构中的条件变量（例如本例中的<code>day</code>），如果存的是整数，需要注意数字和字符的区别。例如</p><p>1</p><p>表示整数1。而</p><p>`1`</p><p>表示字符`1`，对应的ASCII码为49。</p><p>具体使用哪种，取决于你条件变量(<code>day</code>)的类型，例如，<code>int day;</code>或是<code>char day;</code>分别对应例子的前者和后者。这种<code>int</code>和<code>char</code>类型间的关系容易混淆，这是我学习 C 语言过程的困扰过我的问题。</p><p>另外，在使用<code>switch-case</code>语句时，容易漏<code>break;</code>语句和<code>default</code>默认分支。虽然不写也可以，但容易引起BUG，且编译器不会报错。</p><hr><p>上面提到，<code>switch-case</code>结构的条件变量只能是一个确定的值，比如数字或单个字符，所以有时候<code>switch-case</code>结构并不适用，比如我这届以及我下一届的 C 语言课程都有这样一道课后作业，大意是90-100分是优，80-89分是良，要求统计全班优良信息，要求用<code>if-else</code>结构和<code>switch-case</code>结构分别实现。这种”范围判断”的情况，就不适合使用<code>switch-case</code>结构。这种情况，用<code>if-else</code>结构的话，很方便可以实现，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (grade &lt; 100 &amp;&amp; grade &gt; 90)</div><div class="line">&#123;</div><div class="line">	//xxx</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意，下面这样是不行滴，至少在C语言中不行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (90 &lt; grade &lt; 100)</div></pre></td></tr></table></figure><p>那么，或许产生这样的疑问：既然所有的<code>switch-case</code>结构都能转换成<code>if-else</code>结构，那为什么还要有<code>switch-case</code>结构呢？</p><p>结合资料，我说一下我自己的看法。</p><p>###是为了速度快</p><p>这学期我们学”计算机组成原理”，学到了MIPS指令这块，书中提到了<code>switch-case</code>语句的实现和<code>if-else</code>语句的区别之处，摘抄如下（《计算机组成与设计》中文第五版 P64）</p><blockquote><p>大多数程序设计语言中都包括 case 和 switch 语句，使得程序员可以根据某个变量的值选择不同分支之一。实现 switch 语句的最简单方法是借助一系列的条件判断，将 switch 语句转化为 if-then-else 语句。</p><p>有时候另一种更有效的方法是将多个指令序列分支的地址编码为一张表，即<strong>转移地址表(jump address table)</strong>或<strong>转移表(jump table)</strong>，这样程序只需索引该表即可跳转到恰当的指令序列。</p></blockquote><p>总之，用这种转移表，再使用<code>jr</code>(jump register)指令，就能直接跳转到寄存器中存放的地址。速度会比较快。<code>if-else</code>结构，需要从头到尾一一比对，<code>switch-case</code>结构，直接查表就可以了。这种思路类似我觉得类似于路由控制表，即，建立一种一一对应的关系，避免遍历。</p><p>C语言是上世纪70年代发明的，那时候计算机的速度远远不及今天这样快，计算能力也不富裕，所以性能上能省则省。像当今时代的 Java、Python 等等编程语言，执行速度通常比C语言慢，但是换来了更好的安全性、易用性等。Python 语言的语法继承自C语言，但是就没有<code>switch-case</code>结构。</p><p>我想，有种更加量化的办法来验证两者的区别，即，用两种结构分别写两段功能上等价的代码，然后对比编译后的汇编代码。</p><p>以上是我对 C 语言中<code>switch-case</code>结构的一些理解。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/29/2016-3-29/" itemprop="url">三月末</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-03-29T16:20:57+08:00" content="2016-03-29">2016-03-29</time></span></div></header><div class="post-body" itemprop="articleBody"><p>工大校园中，有两棵树我特别喜欢。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/73594368.jpg" alt=""></p><p>(图文无关)</p><p>一颗是旧图门口右手边的那棵树，大概是玉兰吧。开花时香气沁人，而且不仅仅是清香——还有种略微刺激鼻腔的浪漫气味，令人迷醉。人们为此驻足，花香似是热情地诱惑着路人前来学习；又是温柔的奖赏，给那些闭馆时走出图书馆的同学，花香就着月光，让人爱上了春天的热情。</p><p>另一颗树比较隐蔽，是在学生活动中心(团委楼)的东北角，去澡堂的路上可以看到。这棵树开出的花漂亮极了，零零碎碎的白色小花，精致而优雅，没什么气味。花都很小，就着些黄黄绿绿，遮挡不住什么视线，人们尽情地看，她也不会害羞。这棵树两面都是墙，路人匆匆而过，这树没什么存在感——就那样安静地待在那里，亭亭玉立。似是为自己绽放，展示着春天的优雅。</p><p>我想了想，我爱的不是这两棵树，而是这两棵树的花。我觉得他们的花期特别短，往往是下面的花正卯足了劲绽放，上面的花已经感到疲倦，开始往下落了。等再过一个月，花瓣没入尘土，嫩绿的树叶长了出来，大家就都一样了。日复一日的光合作用，使他们运动，使他们变化。如果植物有信仰，太阳一定是他们的神。</p><p>我喜欢树多的地方。有一回，我爬上四教的天台，仔细观察了一下校园中树多的地方，发现有三处。一是北研楼南侧，二是数理楼和教材科之间，三是一教南侧的大林子。还有一排树我也喜欢，就是一号楼南侧的这排——我不知道是不是杨树。这些树很高，高度超过一二号宿舍楼，当树叶都长出来后，给人一种身处树中的幻觉，很是舒适——大概是我儿时对树屋的梦想吧。我现在正坐在宿舍窗边打下这些字，离我咫尺之遥的地方，就是一支伸向我们窗户的树杈，挂着几颗类似花苞的东西，嫩绿嫩绿的，但不是花苞，因为我知道他将开出的是翠色的树叶。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/26780150.jpg" alt=""></p><p>树杈在微风中轻轻摇曳，像是要努力表达什么。我尽力伸出手，但不踮脚就够不到。那距离啊，让我想起了一幅画。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/15240006.jpg" alt=""></p><p>那我们中谁是耶和华？大概是树吧。我觉得从进化的角度来看，树是种相当成功的物种了，比我们人类，比动物，都更成功。毕竟树没什么欲望，假如有欲望我们也无从知晓。他们静静地开花，静静地繁衍，静静地活着。</p><p>我喜欢春天，春天是属于生命的季节，春天是生命力的代言人。曾经一到春天，我还会觉得有些中二的忧伤——春天到了，夏日的狂欢结束后，就是秋天的萧瑟，冬日的肃杀，令人悲伤啊真是。去年这时候，我整个人都非常有活力，搬着相机四处拍照，四处骑车专走野路，四处爬天台，在天台上默念”I’m the king of the world.” 因为我脸皮薄，所以不敢喊出来。今年我平静的多了，也许这就是成长？也许人走入奔三的轨道后，就逐渐丧失了好奇心和热情？我说不好。谁知道呢，让我自己慢慢琢磨吧。先把手头的事弄好，就已经是对得起这春天的太阳了。</p><p>万物生长靠太阳。万物开始生长的三月要结束了，紧接着是万物持续生长的四月。</p><p>感恩太阳！</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/08/alpha-go/" itemprop="url">AlphaGo vs. 李世石，见证历史</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-03-08T19:55:48+08:00" content="2016-03-08">2016-03-08</time></span></div></header><div class="post-body" itemprop="articleBody"><p>明天（3月9日），「人机大战」就要来了。围棋人工智能 AlphaGo 和世界冠军李世石的第一场比赛将于明天打响。网上有多家媒体进行直播，大家不妨关注。</p><p>小时候，我只是隐约听说过卡斯帕罗夫和「深蓝」的那场世纪大战，但却没有什么感受，只是知道「哦，人工智能很厉害，赢了象棋大师」。随着年龄的累加和计算机专业的学习，愈发觉得1997年那场比赛的分量之厚重。1996年，卡斯帕罗夫对垒「深蓝」，以4：2赢得了首战；1997年的重赛中，卡斯帕罗夫以2.5:3.5落败。这次重赛的意义我难以详述，大家如果感兴趣，不妨在网上浏览一下。有意思的是，「深蓝」的设计师叫徐峰雄，和 Facebook 的围棋人工智能一样，设计师都是华人。</p><p>我的QQ网名也叫「深蓝」，有人问过我，这名字是不是指这台计算机？是也不是，因为我确实喜欢深蓝色 :)</p><p>大约是1998年我接触到计算机（一台80286，感谢我的父母），自然不知道也不懂1997年的这件大事。但是这次不同了，上天给了我们一次见证历史的机会。</p><p>这篇文章的标题是「见证历史」，但如果AlphaGo输了，那还见证个啥呢？（笑）</p><p>随着第一战越来越近，各路专业人士也发表了自己的看法。我大致总结了一下：</p><p>围棋选手，基本看好李世石，主流意见是李世石占有压倒性的优势。<br>「我是看好李世石5-0胜，我认为没有别的比分，如果出现别的比分，那么我认为都是商业行为。」中国国家围棋队总教练俞斌如是说。这是比较极端的一类表态。</p><p>人工智能专家，基本看好 AlphaGo，主流意见是双方水平伯仲之间，AlphaGo胜率略大。<br>也许一些人工智能专家已经是在保守表态了，毕竟 AlphaGo 是追赶者、挑战者。挑战的是我们人类对自身智力的骄傲。</p><p>当然，也有学者认为 AlphaGo 会完胜李世石。</p><p>我觉得这次 AlphaGo 应该会全力以赴，毕竟 Facebook 的围棋 AI 也蓄势待发，万一 First Blood 被 Facebook 拿了呢？</p><p>各路表态中，李开复老师的意见较为和谐，认为 AlphaGo 本次胜算不大，但未来1-2年内定会完成超越。我将文章附在下面，转自知乎上李开复老师的回答。</p><p>另外，我相信 AlphaGo 会赢，我也希望它赢。我觉得，哪怕李世石输了，哪怕所有围棋的顶尖高手都输了，这并不是对人类智慧的羞辱，这正是令人类的智慧熠熠发光的大好机会。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/02/18/new-term/" itemprop="url">聊聊新学期的两门课</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-02-18T20:34:19+08:00" content="2016-02-18">2016-02-18</time></span></div></header><div class="post-body" itemprop="articleBody"><p>又开学了。</p><p>这是我们人生中的第28次开学。也许你会多个一两次，少个一两次。不过一样的是，又还剩下多少次呢？</p><p>一眨眼的功夫，大学就过去一年半了。不论是充实、迷茫，快意还是踟蹰，有句话说在当下，我觉得挺应景：</p><p>悟以往之不谏，知来者之可追。</p><p>共勉。</p><hr><p>计科下学期开「数据结构」和「计算机组成原理」，其他专业不了解。我对这两门课也没啥了解，只是聊聊我的看法，希望大家能借此多多交流。</p><p>这两门课都是计算机专业的支柱课程。虽然，从理论上来说，我们学的所有知识都是「有用的」，但我也想说，计算机组成原理的作用，怕是要比电路与模拟电子技术没准儿稍微大那么一点点。</p><p>咱们上学期学了「数字逻辑」这门课，我翻了一下咱们下学期要用的教材，感觉数字逻辑算是计算机组成原理的先修课程。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-2-18/40684185.jpg" alt=""></p><p>咱们大概就是用这门书。这书的附录B，专门是补数字逻辑的内容。上学期学数字逻辑的时候，我有个简单的问题一直没想明白，还以为是自己理解能力实在不行。看着附录突然就明白了。哎。要不然怎么好多人都说尽量读经典教材。</p><p>这书的目录非常有意思，我翻了翻，给我的感觉是这样的：如果说计算机专业就好像是一辆汽车。我们之前学的课程，譬如C语言，C++这些课程，是在学（基础的）开车技巧，那么从这门课开始，也包括从数据结构这门课开始，就要开始打开引擎盖，仔细研究汽车内部的工作原理了。</p><p>当然啦，开车嘛，还有很多高级的技巧，比如下水道过弯之类的。但我想，如果想掌握高级的驾驶技巧，那驾驶员一定是对汽车的运行原理、引擎的内在特性都非常了解，才能掌控汽车的每一个细节。直线上开得快大家都会，油门踩下去就行了；但要开的稳、开的省油，还得靠老司机对汽车性能的深入掌握。</p><p>这些课吧，在我看来，就是走向老司机的必经之路，绕不开的。</p><p>还拿汽车引擎举例子。还有一门课叫「计算机体系结构」，那它和咱们马上要学的「计算机组成原理」是什么关系呢？我的理解是这样的：「计算机组成原理」是把引擎给拆开了，研究引擎到底是怎么运转的。而「计算机体系结构」则更加深入，比如研究引擎的定量性能、结构优化等等。</p><p>大家看上面的配图，「组成」的原文是「Organization」。其实我觉得若译为「组织」更有味道。「计算机为什么要这样组织的原理」，对吧。</p><hr><p>至于数据结构和算法，信安的同学们已经学了，我也就不班门弄斧了。对于不了解的同学，我做个剧透。咱们在C语课设中用到的「链表」，就是数据结构的一种。</p><p>我的理解是这样的：所有计算机程序，抽象出来无非两种内容：数据和算法。数据呢，既然存在计算机里，是需要各种各样不同的储存乃至运算的方式的，这是数据结构和算法所研究的内容。</p><p>计算机究其本质，（在我看来）就是「计算能力」。虽然我是没什么机会能走上探求本质的道路，但真理无穷又如何？进一步有进一步的欢喜。我不是搞理论研究的料子，也许我们中的许多人都不是，但是还是那句话，这课的知识毕竟是老司机的必备内容。更何况如果要考研呢，对吧？</p><p>值得一提的是，我觉得C++和（一部分）离散数学算是数据结构与算法的先修课程。还记得Dijkstra算法不？</p><p>说到这，推荐两篇我非常喜欢的科幻短篇，都蕴含着穷举的思想（可见没有一个好的算法是多么痛苦）：</p><ul><li>《神的九十亿个名字》，亚瑟·克拉克</li><li>《诗云》，刘慈欣</li></ul><p>另外，我在B站发现过一个很有意思的视频，视觉化动态展现15种排序算法。强力治愈强迫症。百看不厌= =</p><p><a href="http://www.bilibili.com/video/av1039639/" target="_blank" rel="external">15种排序算法演示(720p)</a></p><p>番号是1039639.</p><p>如果课本读不下去的话，不妨看看轻松的书。譬如这样的：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-2-18/50511024.jpg" alt=""></p><p>可能比课本和课件都活泼吧。</p><hr><p>欢迎转发，欢迎关注。能偶尔写点字，真的挺开心的。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/31/my-2015/" itemprop="url">2015朝饼夕拾</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-12-31T21:39:49+08:00" content="2015-12-31">2015-12-31</time></span></div></header><div class="post-body" itemprop="articleBody"><p>去年高三，明年大三。</p><p>多有意思，雨峰同学似是有所感怀。他和跟他同龄的很多人，都已经习惯于按学期划分时间。一年两个学期，学期和学期之间是寒暑假。但如果以年来看呢？似乎很少这样想。往回看，真的是高三；往前看，真的是大三。多么奇妙的时间点呀，雨峰同学从未觉得他的生命流逝的如此之快，他觉得自己正在加速——身旁的时间呼啸而过，却愈发看不清事物。路标一晃而过，雨峰同学知道他看到了路标，但似是只有潜意识看到了——他不得不依靠自己的直觉认路，那是多么迷幻的感觉啊。他模糊地觉得加速度越来越大，加速度的加速度也越来越大，所有的一切都越来越大。</p><p>如果我们所生活的世界是个超现实主义作品，那么什么是现实呢？</p><hr><p>生而有涯，知而无涯。</p><p>我翻看了一下手机相册，从2014年7月（刚刚结束高考）一直到如今。我为何感觉时间过得越来越快了，大概是我自己做的事情越来越少了吧，尤其是最近这三四个月。</p><p>2014年末，15年初，我觉得我干了不少事情，相册为证。我觉得我干的最多的事就是：</p><ul><li>四处转悠。</li></ul><p>走路四处转悠，骑车四处转悠，坐地铁四处转悠，做其他交通工具四处转悠。那时的生活似是比现在丰富和精彩很多。如果有人问我我为什么喜欢拍照片？至少对我自己来说，我拍的照片刻画了我的心境。我看我那时拍的照片，我能感到自己的心情非常活跃，似是感觉不到累，充满乐观。</p><p>如今呢，大概是有点懒了吧，同样是一个学期，同样是四个月，生命的客观长度大概是一样的，但生命的主观长度，区别真是想有多大就有多大。</p><p>我们之中，有些人短寿，有些人长寿，但再怎么千差万别，我们的寿命都处在同一个<strong>数量级</strong>。吾生须臾，且行且珍惜吧。路过一只小明，你问，他是在修今生还是修来世呢？</p><p>知而无涯，我觉得不仅仅是知识，也是对这个世界原貌的探索。</p><p>我想我们人类也是动物，我们都愿意像鸵鸟一样将头埋在沙子里；但正因为我们是人类，我们有勇气将头抬起来，面向那刺眼的阳光而不退缩，决绝地顶住狂暴的大风。因为我们都明白，急湍的激流之后和雪白的峭壁之下，是明天的日子，是自由与美好。</p><hr><p>少谈些主义，多研究些问题。</p><p>少说话，多研究些问题。</p><p>少瞎想，多研究些问题。</p><p>以上就是我对我自己的新年祝愿了，假装(或真正地)在成为一名工程师的旅途上进发。</p><p>是那种真正的工程师；</p><p>是那种真正的旅途。</p><hr><p>不管怎么说，2015年结束了，对于95-96年生的人儿来说，这是生命中多么有趣、多么枯燥、多么辉煌、多么失落、多么开心、多么忧愁、多么充满希望、又多么令人迷惘的一年呀！</p><p>祝大家来年吃饼愉快，</p><p>新年快乐！</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/01/shu-zi-luo-ji-shi-yan-tips-1/" itemprop="url">数字逻辑实验，如何使用键盘</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-12-01T18:43:56+08:00" content="2015-12-01">2015-12-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>开关（SW1-SW16）自然也可以作为输入，但有些情况更适合用键盘输入，比如密码锁，模拟投币等。</p><p>键盘就是试验箱右下角，0-F的圆形按钮。</p><p>在做这次实验之前，我原以为键盘的输入方式和开关类似，即按下为1，松开为0，但实际上不是这样。如果想使用键盘，还需要专门写一段「键盘扫描程序」。</p><p>程序在实验书P48页有写，这里解释一下：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">input [7:0] RL;</div><div class="line">...</div><div class="line">output KB;</div><div class="line">reg KB;</div></pre></td></tr></table></figure><p>RL对应键盘的「列」，从左到右，是第0列到第7列。</p><p>KB对应键盘的「行」，当KB为<code>0</code>时，键盘下面一行可用，即0-7.</p><p>当KB为<code>1</code>时，上面一行可用，即8-F.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	q = 1&apos;b0;</div><div class="line">    q = KB;</div><div class="line">    KB = ~q;</div><div class="line">end</div></pre></td></tr></table></figure><p>这段代码是为了以时钟频率反复扫描上下两行，所以时钟不要选太慢的，比如选8Hz就挺合适。</p><hr><p>RL[7]到RL[0]就是列输入，这些需要自行连线。比如从实验板上，将<code>KP_RL7</code>（在键盘上方）连了pin138，那引脚分配的时候，就将138分配给RL[7].请注意，书上的<code>input [7:0] RL</code>这个名字和实验板上的KP_RL0至KP_RL7类似，不要混淆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	case (&#123;KB,RL&#125;)</div><div class="line">        9&apos;b011111110:	//当按下「0」的时候要做的事</div><div class="line">        9&apos;b011111101:	//当按下「1」的时候要干的事</div><div class="line">        ...</div><div class="line">        9&apos;b111111110:	//当按下「8」的时候要干的事</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        default:		//什么按键也没按下</div><div class="line">    endcase</div><div class="line">end</div></pre></td></tr></table></figure><p>这里的<code>{}</code>是用来将两个数拼接在一起。</p><p>KB就表示行，KB为0的话就是下面一行有效。这些键盘是负有效，按下的时候变0，抬起的时候是1.</p><hr><p>实验板上的接线方式，这里给一个参考</p><p>从<code>KP_RL0</code>到<code>KP_RL7</code>，可连接pin166, 164 162 160 158 143 140 138。当然了，连哪个引脚都可以。</p><p><code>KP_RL0/7</code>旁边的<code>KP SL0</code>中，<code>KB1</code>和<code>KB2</code>接地，连接到实验板上任意写有<code>GND</code>的引脚即可。</p><p><code>KB0</code>需要连接到一个你自定义的引脚上（比如163），然后再引脚分配环节，将pin163分配给<code>KB</code>就可以了。</p><hr><p>如果你的电路设计，只需要用一行键盘，那就不需要写KB的0-1转换了。但是仍然要分配KB0，确保KB0恒为0（或恒为1即，用上边一行。）</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/11/23/cpp-keypoint/" itemprop="url">C++考试重点解析 | 七系</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-11-23T13:06:11+08:00" content="2015-11-23">2015-11-23</time></span></div></header><div class="post-body" itemprop="articleBody"><p>老师发来的考点是下面这些（原文）：</p><ol><li>类的静态成员和友元</li><li>数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</li><li>对象指针与动态内存分配</li><li>派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</li><li>虚基类</li><li>单目和双目运算符重载</li><li>多态程序编写，包括虚函数、纯虚函数以及抽象类</li></ol><p>这篇文章中我把这些知识点过一遍，正好我自己也复习一下…如果有错误还请指出，我进行勘误后再发一版。这篇文章不是一篇系统的知识点回顾，其中有很多我个人的理解，不甚准确，仅供有限的参考。另外，我的C++学的也比较一般，所以也希望能借此机会和大家多交流。</p><p>另外还请注意的是，咱们的课本写的还是挺清楚的，将这些知识点在书上找出来，再看几遍即可。</p><p>##1.类的静态成员和友元</p><p>###1.1关键字</p><ul><li>静态成员：static</li><li>友元：friend</li></ul><p>###1.2静态成员<br>定义：如果有一个成员，需要和他所属的<strong>类</strong>直接相关，而不是和由这个类生成的<strong>对象</strong>直接相关，此时需要静态成员。</p><p>举例：“北工大学生”作为一个类，可以派生出你，你，你，我，每一个人。而这个类中有一个成员变量“学生总数”，这个成员只和“北工大学生”这个类相关，而不和具体的某个学生对象相关。<br>比如说，“学生总数”这个<strong>成员</strong>，和“王大水”这个<strong>对象</strong>没有关系。</p><p>此时，如果修改任意一个对象中的静态成员，所有派生自同一个类的此静态成员都会同时被改变。也就是说，所有的由此类派生出的对象，都共享同一份静态成员，一变都变。</p><p>使用方法：在成员的声明前加上<code>static</code>。</p><p>比如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>此时，total前的<code>static</code>就是将此变量声明为静态成员的意思。</p><p>当然，<code>static</code>也可以加在<strong>成员函数</strong>的声明前。有什么用呢？比如说，你想在<strong>类还没实例化之前，就修改static变量的值</strong>，那这个修改用的函数也得是<code>static</code>的。</p><p>这块知识基本可以类比Java中学过的<code>Static</code>。</p><p>###1.3友元</p><p>友元的预备知识：访问的控制与封装，即<code>public</code>，<code>protected</code>，<code>private</code>关键字的功能。</p><p>可以这样不严谨但通俗地理解：</p><ul><li><code>public</code>：谁都能来使用我的东西，来者不拒</li><li><code>protected</code>：只有我的孩子孙子（继承自我的类）才能用我的东西</li><li><code>private</code>：只有我自己才能用我自己的东西</li></ul><p>友元的作用，是指定某一个函数(或某一个类的成员函数)“为自己的好朋友”，即可以使用自己的private内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span>;    <span class="comment">//const引用</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//输出信息用的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student stu1;</div><div class="line">    print (stu1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果print是一个用来输出学生对象中信息的函数，那这种方法(加friend)就相当于给了<code>print</code>函数一个特殊的权限。</p><p><code>friend</code>作用在<strong>类的成员函数</strong>时，用法也是一样的。</p><p>友元声明不写在<code>public</code>或<code>private</code>区域中。</p><p>总之，两个类之间需要共享数据的时候，可以使用友元。但请注意，友元实质上破坏了类的封装性。Java中就没有友元函数这一设定。</p><p>##2.数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</p><p>###2.1.数组作为函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * a)</span></span>;  <span class="comment">//声明方法1</span></div><div class="line"><span class="comment">//void sum(int [] a);   //声明方法2，这样也行</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">20</span>];  <span class="comment">//声明数组</span></div><div class="line">    sum (a);    <span class="comment">//传递这个数组为函数参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C语言里学过。形式大概就是上面这样。</p><p>###2.2指针作为函数参数，与地址相关的运算 <code>*</code> 和 <code>&amp;</code></p><p>C和C++语言中，同一个符号在不同的场合会有不同的意思。在和地址相关时：</p><ul><li><code>&amp;</code> ： 取址符</li><li><code>*</code> ： 取值符</li></ul><p>他们俩互为逆运算。<code>&amp;</code>就是取一个变量的地址（通常情况下，也就是指针的意思，但请不要认为地址==指针）。</p><p><code>*</code>的话就是“取一个地址内的值”，和上面的<code>&amp;</code>的操作正好相反。</p><p>就好比说，宿舍号“424”是一个地址，你取424的值，即<code>*424</code>，取出来的就是“王大水”这个值。如果你对“王大水”进行取址，即<code>&amp;王大水</code>，结果就是424.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> * p)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</div><div class="line">    <span class="keyword">int</span> * pointer1 = &amp;a;    <span class="comment">//将a的地址赋给指针pointer1</span></div><div class="line">    func(pointer1); <span class="comment">//指针作为函数参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> * p)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; p;      <span class="comment">//输出的是a的地址，即主函数中的&amp;a</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *p;     <span class="comment">//输出的是a的值，即233</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>##3.对象指针与动态内存分配</p><p>###3.1.对象指针</p><p>如果有一个指针<strong>指向了一个对象</strong>，那这个指针就是<strong>对象指针</strong>了。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student * pb = student1;   <span class="comment">//pb指向了对象student1，pb的类型是"BJUT_Student"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###3.2.动态内存分配</p><p>咱们在C语言里学过<code>malloc</code>，写法比较繁琐，一般是</p><figure class="highlight plain"><figcaption><span>* BJUT_Student = (BJUT_Student*)malloc(sizeof(BJUT_Student));```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在C++里大幅简化了这个功能（申请内存），约等于</div><div class="line"></div><div class="line">```BJUT_Student * student1 = new BJUT_Student();</div></pre></td></tr></table></figure><p>方便多了吧。</p><p>在C++里，尽量使用<code>new</code>，尽量不使用属于C语言的函数(例如<code>malloc</code>)。</p><p>##4.派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</p><p>###4.1.派生类的构造函数和析构函数</p><ul><li>构造函数：用来在新生成一个对象时初始化一些内容</li><li>析构函数：用来执行在销毁一个对象时要做的一些事情</li></ul><p>一般情况下，手写构造函数比较频繁，手写析构函数的机会不多。C++ Runtime 会自动为我们做一些事。</p><p>ps：构造函数在定义的时候，需要和<strong>类名相同</strong>。</p><p>派生类：即从已有的类继承而来的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A     <span class="comment">//基类A</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">int</span> x)&#123;</div><div class="line">        a = x;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    B(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : A(x)  <span class="comment">//派生类的构造函数，冒号后的是“初始化列表”</span></div><div class="line">    &#123;</div><div class="line">        b = y;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是这个意思，B继承自A。派生类的构造函数执行的时候，先执行父类的构造函数，也就是说<strong>初始化列表</strong>中的<code>: A(x)</code>.</p><p>析构函数也和类同名，但前面加了一个<code>~</code>，例如<code>~B(){//xxxxx}</code>。上述代码中没写析构函数。</p><p>派生类中的析构函数，执行的时候和构造函数的顺序相反，即先析构自己，再析构父类。<strong>除非</strong>父类的析构函数是虚函数(virtual)。</p><p>我还从来没实际用过析构函数，所以对这块不了解。一般情况下，对象销毁的时候，系统都自动为我们执行很多相当于析构函数的工作了。</p><p>关于“初始化列表”，可以简单的说：能用初始化列表的场合，都尽量使用初始化列表。尤其是，当某些const类型和引用类型的成员变量需要被初始化时，必须使用初始化列表，因为const或引用变量无法被复制（除初始化时）。</p><p>##4.2.复制构造函数</p><p>就我所知，一般在</p><ul><li>将对象作为参数传递，且为<strong>值传递</strong>的时候需要用到复制构造函数。</li><li>return一个对象。</li><li>纯粹复制一个对象。</li><li>构造一个对象时需要复制另外一个对象。</li></ul><p>说白了就是用来复制一个对象用的函数。关于值传递和地址传递的区别，可以参考我之前写过的文章。</p><p>复制构造函数的写法：一个<strong>参数为类的引用</strong>的构造函数，参数最好是const。例如：</p><p>复制构造函数在本质上还是构造函数，区别在于参数不同，用途不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B(<span class="keyword">const</span> B&amp;);    <span class="comment">//复制构造函数的声明</span></div><div class="line"></div><div class="line">B:B(<span class="keyword">const</span> B&amp; p)&#123; <span class="comment">//复制构造函数的定义</span></div><div class="line">    b = p.b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我的理解是：复制构造函数，就是一个明确指定“如何复制一个对象”的函数。</p><p>#4.3.派生类成员的标识与访问</p><p>不明白这是在说啥…</p><p>#5.虚基类</p><p>即在继承一个类的时候，在被继承的类名前面加个virtual。这在多继承时才会被用到。是为了消除二义性。</p><p>比如有基类A，B继承自A，C继承自A，又有D多继承自B和C。此时D中继承自A的成员，到底是哪一个A呢？（因为B和C分别复制了一份A的成员）这就产生了冲突。</p><p>如果在B和C继承A的时候，将A声明为<strong>虚基类</strong>即可解决这个问题，虚基类会确保A中的成员有且只有一份，D调用的时候就不会产生冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    A a;</div><div class="line">    B b;</div><div class="line">    C c;</div><div class="line"></div><div class="line">    a.i = <span class="number">1</span>;</div><div class="line">    a.print();</div><div class="line"></div><div class="line">    b.i = <span class="number">2</span>;</div><div class="line">    b.print();</div><div class="line"></div><div class="line">    c.i = <span class="number">3</span>;</div><div class="line">    c.print();</div><div class="line"></div><div class="line">    D d;</div><div class="line">    d.i = <span class="number">4</span>;    <span class="comment">//消除了二义性，如果不用虚继承，此处编译出错</span></div><div class="line">    d.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虚基类这事儿不常用。可以参考Java语言：根本就没有多继承，所以也不用操心这些事儿。</p><p>注：在Java中，和「多继承」类似的功能一般靠接口(interface)实现。</p><p>##6.单目和双目运算符重载</p><p>运算符重载是C++的一个特点，另一门面相对象语言即Java中，就没有运算符重载。因为他们的设计哲学有区别吧。</p><p>之前咱们学过函数的重载，即，当函数名相同，但函数参数列表不同时，程序会根据咱们实际所给的参数列表，动态地选择应调用的函数。</p><p>运算符重载也差不多，经过重载，同样地运算符在参与不同的数据类型（比如：int，double 就是两种不同的数据类型），会有不同的表现。</p><p>这是双目运算符的重载：(课本P310)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">Complex::<span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> Complex(<span class="keyword">this</span>.real + c2.real, <span class="keyword">this</span>.imag + c2.imag);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在双目运算符的重载中，运算符左边的操作数就是this。this一般可以省略。右操作数作为参数传递进来，也就是说这里的c2.</p><p>为什么需要重载这个加号呢？因为<code>Complex</code>类型是用户自定义的类型，C++编译器不知道该如何将两个这样的对象“加”在一起，需要用户手动描述。</p><p>单目运算符的重载也是一个意思。比较常用的单目运算符重载是<code>++</code>,<code>--</code>，值得注意的是，单目运算符重载一般没有参数（被运算的数作为this指针隐式传递）。</p><p>还有一种情况，即用友元函数进行运算符重载，这样的话，双目运算符重载就有两个参数，单目运算符重载就有一个参数。因为友元函数运算符重载没有this指针。</p><p>关于自增运算符前置、后置的重载，可以参考课本P312，非常清楚。</p><p>##7.多态程序编写，包括虚函数、纯虚函数以及抽象类</p><p>###7.1.多态，虚函数</p><p>什么是多态呢…</p><p>书上的定义不太好理解，一般都是类似于“对同一个消息作用在不同的对象上，会产生不同的效果”。你可能会问，这不是废话吗？比如有个父类Animal，子类Dog，我让Animal“吃”，和让Dog“吃”，效果肯定不一样啊，这还用系统给我判断？</p><p>你说的没什么错。按照我的理解，什么时候需要多态性呢？</p><p>比如有个<code>Animal</code>类型的指针<code>a</code>，这个指针<code>a</code>指向<code>Animal</code>的时候，你调用<code>a.eat()</code>。指针再指向<code>Dog</code>的时候，你又调用<code>a.eat()</code>。此时如果能分别正确调用<code>Animal</code>和<code>Dog</code>的<code>eat()</code>方法，那这就是多态。</p><p>如果你分别用指向<code>Animal</code>和指向<code>Dog</code>的指针，分别调用<code>eat()</code>，这就不叫多态。</p><p>多态这件事和<strong>继承</strong>是<strong>紧密相连</strong>的。</p><p>咱们应该是都学过Java了，为啥Java中没怎么提到过多态呢？确实如此，因为Java中的类的继承，在默认的情况下就已经实现了多态了。</p><p>但C++就没这么自动化，如果想让一个父类的某个成员函数能实现多态性，就必须规定这个函数为<code>虚函数</code>。</p><p>用刚才那个例子来说，也就是说得让Animal类中的eat()方法前加上一个virtual。类似：</p><figure class="highlight plain"><figcaption><span>void eat()&#123;//xxx&#125;;```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###7.2.纯虚函数</div><div class="line"></div><div class="line">纯虚函数是一种特殊的虚函数。即只声明，不实现定义。由继承下去的子类去具体实现。</div><div class="line"></div><div class="line">写法是这样：</div><div class="line"></div><div class="line">```virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</div></pre></td></tr></table></figure><p>加了一个<code>=0</code>。注意,<code>virtual</code>也不能少。</p><p>我个人理解：纯虚函数对应Java中的抽象(Abstract)函数。</p><p>###7.3.抽象类</p><p>只要是包含了纯虚函数的类就自动被归为抽象类。和Java中的抽象类类似，不能被实例化为对象，只能被继承。</p><p>抽象类中至少存在一个纯虚函数；存在纯虚函数的类一定是抽象类。存在纯虚函数是成为抽象类的充要条件。</p><h2 id="完毕。"><a href="#完毕。" class="headerlink" title="完毕。"></a>完毕。</h2><p>C++的确很有用，非常强大，效率很高。坦诚地讲，也很有学习的必要。但从我个人的角度，以及我目前对C++及其浅薄的认识，我不是很喜欢C++这门语言给我的感觉。强类型的面向对象语言中，我更喜欢Java。目前我正在(以极其缓慢、肉眼几乎难以辨别的速度)学习Python，如果有同感兴趣的朋友请一起来交流。</p><p>当然了，我想强调的是，我承认C++作为<strong>基石</strong>的作用。我也同意，作为计算机专业的学生，有必要对C++进行相对深度的学习。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/10/27/DC-regulated-power/" itemprop="url">直流稳压电源(电路实验1)笔记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-10-27T17:38:05+08:00" content="2015-10-27">2015-10-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>电子实验的第一个实验，「直流稳压电源」。由于实验小册子上的图和文字实在是太抽象、太魔性了，我把我对这个电路的一些认识写在这里，供参考。如果写错了内容并对你的电路(和心理)造成了不可逆转的伤害，我请你吃冰棍。</p><p>另外，我的器件包里没有任何<strong>电阻</strong>，但 @辛德龙 就有俩氪金彩色电阻，大家都有电阻吗？</p><p>#认识元器件</p><p>元件和器件是有区别的。在我看来，电阻、电容这类比较基础的东西就是「元件」，差分放大器、集成电路的话就算「器件」</p><p>##电解电容（大）<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/82966437.jpg" alt=""></p><p>1000μF</p><p>和整流桥并联。</p><p>给转换出的直流电做滤波(?)和稳压(?)用的，总之是个缓冲作用。这个电路上大多数的电容都是缓冲作用。</p><p><strong>听说这个电容接反的话会爆炸。</strong>，有白条的一侧就是负极。同时，引脚长的一侧为正极。</p><p>这个黑色电解电容，从包装来看是Rubycon牌子的，我上网查了一下，怀疑是假货。</p><p>##电解电容（小）</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/62548616.jpg" alt=""></p><p>数量若干。</p><p>##陶瓷电容</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26675224.jpg" alt=""></p><p>这种电容不用分正负。听说也不会爆炸？</p><p>##整流桥</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/24418714.jpg" alt=""></p><p>能将交流电转为（<em>不那么平整的</em>）直流电。大约是1V交流电（有效值）能转为1.2V直流电。</p><p>看印刷，<strong>两个「~」接交流电，「+」和「-」就是直流输出</strong>。</p><p>其实就是小册子上的这玩意：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/46572702.jpg" alt=""></p><p>因为这个整流桥的内部就是封装了4个二极管。</p><p>##二极管</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/73668153.jpg" alt=""></p><p>型号：1N4007</p><p><strong>有白环的一侧为负极</strong>。在咱们这个电路中，接在7805的1，3引脚之间，保护用。引脚3接二极管正极。</p><p>##稳压器</p><p>型号可能是「LM7805」</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/16602044.jpg" alt=""></p><p>从印刷字的一侧看，<strong>左起为引脚1，2，3</strong>。1接正极，3接输出，2接地。</p><p>由于经过整流桥整流过的直流电，还不是很平整（参考上面整流桥的波形图），这个7805就是撸平电流用的，作用类似电熨斗。</p><p>这个7805稳压器能稳定输出5V直流电源，输入的话一般在7-10V。那这几V的电去哪了？被这个器件变成热量了。上面的那个孔，就是接散热片用的。不过咱们这个电路电流不大，我估计不需要散热片。</p><p>##功率放大器</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26540379.jpg" alt=""></p><blockquote><p>图：百度图片</p></blockquote><p>其实已经不是「直流稳压」部分的功能了。估计是为了驱动喇叭。</p><p>咱们给的是「386D」，和「LM386」的原理基本一样，应该是生产的厂商不一样。</p><p>有圆形凹陷的那个角，是引脚1（所有器件都这样）。引脚图：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/76078863.jpg" alt=""></p><blockquote><p>图：JRC的器件手册</p></blockquote><ul><li>引脚1，8：接一个电容，调节用</li><li>引脚2：反相输入（信号源）</li><li>引脚3：正相输入（信号源）</li><li>引脚4：接地</li><li>引脚5：输出信号</li><li>引脚6：电源（在咱们这个实验中就是7805给的5V直流）</li><li>引脚7：旁路（接一个电容，电容再接地。好像是对输出信号的稳定有好处）（去耦?）</li></ul><p>反相和正相输入，大概就是咱们电路课正在学的功率放大器吧。</p><p>##管脚座(?)</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/30867599.jpg" alt=""></p><p>386一定要插在管脚座上，将管脚座焊接在电路板上。我不确定是不是叫「管脚座」这个名字。</p><p>建议7805也接在座上，毕竟听说<em>电烙铁可能会焊坏器件（给的热量太多）</em></p><p>#电路图</p><p>小册子上的图太魔性了简直。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/43741313.jpg" alt=""></p><p>感谢 @曾檬 @孙昀淏 分享图片，拯救我于水火之中。此图建议大家存好，你懂得。</p><p>#总之<br>想搞一个8Ω小喇叭，没搞来。</p><p>焊锡就给那么点，器件焊坏了还不给分，这真的是实验课？这让人怎么练手？非得让人缩手缩脚？一个器件有几块钱？我出钱买还不行吗？焊坏一个器件就不给分？</p><p>##接地是啥意思？</p><p>我理解接地，就是接「低电平」的意思，在咱们这个电路中，唯一可行的低电平就是电源负极。也就是说接地就是接电源负极的意思。</p><p>没必要接大地。</p><p>##一些笔记</p><ul><li>防止输入对地短路</li><li>防止输入输出接反</li><li>防止输入滤波电路短路（大概会爆炸？）</li><li>防止输出与高电平接（大概会烧坏器件）</li><li>防止三 - 地 - 开路 （原文如此，我也忘了记的是啥意思了，求解）</li></ul><p>##总之</p><p>这个电路：</p><ol><li>将交流电，用整流桥（扁平圆柱，四脚），变成不平整的直流电</li><li>将不平整的直流电，用稳压器（7805，三脚），变成平滑的5V直流电</li><li>用5V的直流电驱动功放（386D，八脚）</li></ol></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person"><img class="site-author-image" itemprop="image" src="http://7xku3h.com1.z0.glb.clouddn.com/alanwang.png" alt="Alan"><p class="site-author-name" itemprop="name">Alan</p><p class="site-description motion-element" itemprop="description">Alan Wang's personal blog.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">60</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="http://www.devchen.com/" target="_blank" title="十七的空指针"><i class="fa fa-fw fa-globe"></i> 十七的空指针</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Alan</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script></body></html>