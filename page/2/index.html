<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.gmirror.org/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="http://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css"><meta name="keywords" content="王雨峰, 博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2"><meta name="description" content="Alan Wang&apos;s personal blog."><meta property="og:type" content="website"><meta property="og:title" content="王雨峰的博客"><meta property="og:url" content="http://wangyufeng.org/page/2/index.html"><meta property="og:site_name" content="王雨峰的博客"><meta property="og:description" content="Alan Wang&apos;s personal blog."><meta name="twitter:card" content="summary"><meta name="twitter:title" content="王雨峰的博客"><meta name="twitter:description" content="Alan Wang&apos;s personal blog."><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"}}</script><link rel="canonical" href="http://wangyufeng.org/page/2/"><title>王雨峰的博客</title></head><body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="//schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">王雨峰的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">随便写点东西，为互联网贡献一些比特。</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/04/11/char-to-tchar/" itemprop="url">EasyX中的TCHAR转换</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-04-11T08:41:21+08:00" content="2016-04-11">2016-04-11</time></span></div></header><div class="post-body" itemprop="articleBody"><p>EasyX 库中的 <code>outtextxy()</code>函数只能接受<code>TCHAR</code>格式的参数。</p><p>提供几种用过的常用数据格式转<code>TCHAR</code>的方法，供参考。如果不行，不妨再用 Google。关键词：xxx to TCHAR.</p><p>ps. <code>wchar_t</code> 和 <code>TCHAR</code> 在EasyX的应用中是一个意思，用哪个都行。他们都是为了处理Unicode字符而存在的，在咱们的EasyX程序中就是为了处理中文，但是其他西文字符也得转成TCHAR。</p><hr><p>说明：</p><ul><li>源数据：source</li><li>转换后的数据：dest</li></ul><p>###先要包含头文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;tchar.h&gt;</div></pre></td></tr></table></figure><p></p><p>###直接输出TCHAR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">outtextxy(x, y,  _T(&quot;要输出的字符串&quot;));</div></pre></td></tr></table></figure><p>###string 转 TCHAR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//先包含头文件</div><div class="line">#include &lt;atlstr.h&gt;	</div><div class="line"></div><div class="line">_tcscpy_s(dest, CA2T(source.c_str()));</div></pre></td></tr></table></figure><h3 id="int-转-TCHAR"><a href="#int-转-TCHAR" class="headerlink" title="int 转 TCHAR"></a>int 转 TCHAR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_stprintf_s(dest, _T(&quot;%d&quot;), source);</div></pre></td></tr></table></figure><h3 id="char-转-TCHAR"><a href="#char-转-TCHAR" class="headerlink" title="char 转 TCHAR"></a>char 转 TCHAR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_stprintf_s(dest, _T(&quot;%c&quot;), source);</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MultiByteToWideChar(CP_ACP, 0, source, 20, dest, 20);</div><div class="line">//20是长度</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/04/07/c-switch/" itemprop="url">C 语言中为什么有 switch？ | 七系</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-04-07T18:30:02+08:00" content="2016-04-07">2016-04-07</time></span></div></header><div class="post-body" itemprop="articleBody"><p>如果文中有BUG，请留言反馈，谢谢~</p><hr><p>C语言中，有且仅有三种基本语句结构</p><ol><li>顺序结构</li><li>循环结构(<code>while</code>, <code>for</code>等)</li><li>条件结构</li></ol><p>其中，条件结构有<code>if-else</code>和<code>switch-case</code>两种。还有<code>三元运算符</code>，形如<code>a &gt; b ? c : d;</code>不常用。</p><p>经常地，<code>if-else</code>结构和<code>switch-case</code>结构可以相互转化。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">switch (day)</div><div class="line">&#123;</div><div class="line">    case &apos;1&apos; : printf(&quot;Monday\n&quot;);  break;</div><div class="line">    case &apos;2&apos; : printf(&quot;Tuesday\n&quot;); break;</div><div class="line">    case 1 : printf(&quot;1\n&quot;); break;	//注意1和&apos;1&apos;的区别</div><div class="line">    default : printf(&quot;error\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以转换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (day == &apos;1&apos;)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Monday\n&quot;);</div><div class="line">&#125; </div><div class="line">else if (day == &apos;2&apos;)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Tuesday\n&quot;);</div><div class="line">&#125; </div><div class="line">else if (day == 1)</div><div class="line">&#123;</div><div class="line">    printf(&quot;1\n&quot;);</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    printf(&quot;error\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两者实现的功能是一样的。一般来说，<code>if-else</code>结构相对于<code>switch-case</code>结构来说更为灵活一些，比如，分支的条件可以是”一定范围”，但<code>switch-case</code>结构的条件变量必须是整数或字符，或枚举型。</p><hr><p>题外话：这里想强调的是，<code>switch-case</code>结构中的条件变量（例如本例中的<code>day</code>），如果存的是整数，需要注意数字和字符的区别。例如</p><p>1</p><p>表示整数1。而</p><p>`1`</p><p>表示字符`1`，对应的ASCII码为49。</p><p>具体使用哪种，取决于你条件变量(<code>day</code>)的类型，例如，<code>int day;</code>或是<code>char day;</code>分别对应例子的前者和后者。这种<code>int</code>和<code>char</code>类型间的关系容易混淆，这是我学习 C 语言过程的困扰过我的问题。</p><p>另外，在使用<code>switch-case</code>语句时，容易漏<code>break;</code>语句和<code>default</code>默认分支。虽然不写也可以，但容易引起BUG，且编译器不会报错。</p><hr><p>上面提到，<code>switch-case</code>结构的条件变量只能是一个确定的值，比如数字或单个字符，所以有时候<code>switch-case</code>结构并不适用，比如我这届以及我下一届的 C 语言课程都有这样一道课后作业，大意是90-100分是优，80-89分是良，要求统计全班优良信息，要求用<code>if-else</code>结构和<code>switch-case</code>结构分别实现。这种”范围判断”的情况，就不适合使用<code>switch-case</code>结构。这种情况，用<code>if-else</code>结构的话，很方便可以实现，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (grade &lt; 100 &amp;&amp; grade &gt; 90)</div><div class="line">&#123;</div><div class="line">	//xxx</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意，下面这样是不行滴，至少在C语言中不行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (90 &lt; grade &lt; 100)</div></pre></td></tr></table></figure><p>那么，或许产生这样的疑问：既然所有的<code>switch-case</code>结构都能转换成<code>if-else</code>结构，那为什么还要有<code>switch-case</code>结构呢？</p><p>结合资料，我说一下我自己的看法。</p><p>###是为了速度快</p><p>这学期我们学”计算机组成原理”，学到了MIPS指令这块，书中提到了<code>switch-case</code>语句的实现和<code>if-else</code>语句的区别之处，摘抄如下（《计算机组成与设计》中文第五版 P64）</p><blockquote><p>大多数程序设计语言中都包括 case 和 switch 语句，使得程序员可以根据某个变量的值选择不同分支之一。实现 switch 语句的最简单方法是借助一系列的条件判断，将 switch 语句转化为 if-then-else 语句。</p><p>有时候另一种更有效的方法是将多个指令序列分支的地址编码为一张表，即<strong>转移地址表(jump address table)</strong>或<strong>转移表(jump table)</strong>，这样程序只需索引该表即可跳转到恰当的指令序列。</p></blockquote><p>总之，用这种转移表，再使用<code>jr</code>(jump register)指令，就能直接跳转到寄存器中存放的地址。速度会比较快。<code>if-else</code>结构，需要从头到尾一一比对，<code>switch-case</code>结构，直接查表就可以了。这种思路类似我觉得类似于路由控制表，即，建立一种一一对应的关系，避免遍历。</p><p>C语言是上世纪70年代发明的，那时候计算机的速度远远不及今天这样快，计算能力也不富裕，所以性能上能省则省。像当今时代的 Java、Python 等等编程语言，执行速度通常比C语言慢，但是换来了更好的安全性、易用性等。Python 语言的语法继承自C语言，但是就没有<code>switch-case</code>结构。</p><p>我想，有种更加量化的办法来验证两者的区别，即，用两种结构分别写两段功能上等价的代码，然后对比编译后的汇编代码。</p><p>以上是我对 C 语言中<code>switch-case</code>结构的一些理解。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/29/2016-3-29/" itemprop="url">三月末</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-03-29T16:20:57+08:00" content="2016-03-29">2016-03-29</time></span></div></header><div class="post-body" itemprop="articleBody"><p>工大校园中，有两棵树我特别喜欢。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/73594368.jpg" alt=""></p><p>(图文无关)</p><p>一颗是旧图门口右手边的那棵树，大概是玉兰吧。开花时香气沁人，而且不仅仅是清香——还有种略微刺激鼻腔的浪漫气味，令人迷醉。人们为此驻足，花香似是热情地诱惑着路人前来学习；又是温柔的奖赏，给那些闭馆时走出图书馆的同学，花香就着月光，让人爱上了春天的热情。</p><p>另一颗树比较隐蔽，是在学生活动中心(团委楼)的东北角，去澡堂的路上可以看到。这棵树开出的花漂亮极了，零零碎碎的白色小花，精致而优雅，没什么气味。花都很小，就着些黄黄绿绿，遮挡不住什么视线，人们尽情地看，她也不会害羞。这棵树两面都是墙，路人匆匆而过，这树没什么存在感——就那样安静地待在那里，亭亭玉立。似是为自己绽放，展示着春天的优雅。</p><p>我想了想，我爱的不是这两棵树，而是这两棵树的花。我觉得他们的花期特别短，往往是下面的花正卯足了劲绽放，上面的花已经感到疲倦，开始往下落了。等再过一个月，花瓣没入尘土，嫩绿的树叶长了出来，大家就都一样了。日复一日的光合作用，使他们运动，使他们变化。如果植物有信仰，太阳一定是他们的神。</p><p>我喜欢树多的地方。有一回，我爬上四教的天台，仔细观察了一下校园中树多的地方，发现有三处。一是北研楼南侧，二是数理楼和教材科之间，三是一教南侧的大林子。还有一排树我也喜欢，就是一号楼南侧的这排——我不知道是不是杨树。这些树很高，高度超过一二号宿舍楼，当树叶都长出来后，给人一种身处树中的幻觉，很是舒适——大概是我儿时对树屋的梦想吧。我现在正坐在宿舍窗边打下这些字，离我咫尺之遥的地方，就是一支伸向我们窗户的树杈，挂着几颗类似花苞的东西，嫩绿嫩绿的，但不是花苞，因为我知道他将开出的是翠色的树叶。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/26780150.jpg" alt=""></p><p>树杈在微风中轻轻摇曳，像是要努力表达什么。我尽力伸出手，但不踮脚就够不到。那距离啊，让我想起了一幅画。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/15240006.jpg" alt=""></p><p>那我们中谁是耶和华？大概是树吧。我觉得从进化的角度来看，树是种相当成功的物种了，比我们人类，比动物，都更成功。毕竟树没什么欲望，假如有欲望我们也无从知晓。他们静静地开花，静静地繁衍，静静地活着。</p><p>我喜欢春天，春天是属于生命的季节，春天是生命力的代言人。曾经一到春天，我还会觉得有些中二的忧伤——春天到了，夏日的狂欢结束后，就是秋天的萧瑟，冬日的肃杀，令人悲伤啊真是。去年这时候，我整个人都非常有活力，搬着相机四处拍照，四处骑车专走野路，四处爬天台，在天台上默念”I’m the king of the world.” 因为我脸皮薄，所以不敢喊出来。今年我平静的多了，也许这就是成长？也许人走入奔三的轨道后，就逐渐丧失了好奇心和热情？我说不好。谁知道呢，让我自己慢慢琢磨吧。先把手头的事弄好，就已经是对得起这春天的太阳了。</p><p>万物生长靠太阳。万物开始生长的三月要结束了，紧接着是万物持续生长的四月。</p><p>感恩太阳！</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/08/alpha-go/" itemprop="url">AlphaGo vs. 李世石，见证历史</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-03-08T19:55:48+08:00" content="2016-03-08">2016-03-08</time></span></div></header><div class="post-body" itemprop="articleBody"><p>明天（3月9日），「人机大战」就要来了。围棋人工智能 AlphaGo 和世界冠军李世石的第一场比赛将于明天打响。网上有多家媒体进行直播，大家不妨关注。</p><p>小时候，我只是隐约听说过卡斯帕罗夫和「深蓝」的那场世纪大战，但却没有什么感受，只是知道「哦，人工智能很厉害，赢了象棋大师」。随着年龄的累加和计算机专业的学习，愈发觉得1997年那场比赛的分量之厚重。1996年，卡斯帕罗夫对垒「深蓝」，以4：2赢得了首战；1997年的重赛中，卡斯帕罗夫以2.5:3.5落败。这次重赛的意义我难以详述，大家如果感兴趣，不妨在网上浏览一下。有意思的是，「深蓝」的设计师叫徐峰雄，和 Facebook 的围棋人工智能一样，设计师都是华人。</p><p>我的QQ网名也叫「深蓝」，有人问过我，这名字是不是指这台计算机？是也不是，因为我确实喜欢深蓝色 :)</p><p>大约是1998年我接触到计算机（一台80286，感谢我的父母），自然不知道也不懂1997年的这件大事。但是这次不同了，上天给了我们一次见证历史的机会。</p><p>这篇文章的标题是「见证历史」，但如果AlphaGo输了，那还见证个啥呢？（笑）</p><p>随着第一战越来越近，各路专业人士也发表了自己的看法。我大致总结了一下：</p><p>围棋选手，基本看好李世石，主流意见是李世石占有压倒性的优势。<br>「我是看好李世石5-0胜，我认为没有别的比分，如果出现别的比分，那么我认为都是商业行为。」中国国家围棋队总教练俞斌如是说。这是比较极端的一类表态。</p><p>人工智能专家，基本看好 AlphaGo，主流意见是双方水平伯仲之间，AlphaGo胜率略大。<br>也许一些人工智能专家已经是在保守表态了，毕竟 AlphaGo 是追赶者、挑战者。挑战的是我们人类对自身智力的骄傲。</p><p>当然，也有学者认为 AlphaGo 会完胜李世石。</p><p>我觉得这次 AlphaGo 应该会全力以赴，毕竟 Facebook 的围棋 AI 也蓄势待发，万一 First Blood 被 Facebook 拿了呢？</p><p>各路表态中，李开复老师的意见较为和谐，认为 AlphaGo 本次胜算不大，但未来1-2年内定会完成超越。我将文章附在下面，转自知乎上李开复老师的回答。</p><p>另外，我相信 AlphaGo 会赢，我也希望它赢。我觉得，哪怕李世石输了，哪怕所有围棋的顶尖高手都输了，这并不是对人类智慧的羞辱，这正是令人类的智慧熠熠发光的大好机会。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/02/18/new-term/" itemprop="url">聊聊新学期的两门课</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-02-18T20:34:19+08:00" content="2016-02-18">2016-02-18</time></span></div></header><div class="post-body" itemprop="articleBody"><p>又开学了。</p><p>这是我们人生中的第28次开学。也许你会多个一两次，少个一两次。不过一样的是，又还剩下多少次呢？</p><p>一眨眼的功夫，大学就过去一年半了。不论是充实、迷茫，快意还是踟蹰，有句话说在当下，我觉得挺应景：</p><p>悟以往之不谏，知来者之可追。</p><p>共勉。</p><hr><p>计科下学期开「数据结构」和「计算机组成原理」，其他专业不了解。我对这两门课也没啥了解，只是聊聊我的看法，希望大家能借此多多交流。</p><p>这两门课都是计算机专业的支柱课程。虽然，从理论上来说，我们学的所有知识都是「有用的」，但我也想说，计算机组成原理的作用，怕是要比电路与模拟电子技术没准儿稍微大那么一点点。</p><p>咱们上学期学了「数字逻辑」这门课，我翻了一下咱们下学期要用的教材，感觉数字逻辑算是计算机组成原理的先修课程。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-2-18/40684185.jpg" alt=""></p><p>咱们大概就是用这门书。这书的附录B，专门是补数字逻辑的内容。上学期学数字逻辑的时候，我有个简单的问题一直没想明白，还以为是自己理解能力实在不行。看着附录突然就明白了。哎。要不然怎么好多人都说尽量读经典教材。</p><p>这书的目录非常有意思，我翻了翻，给我的感觉是这样的：如果说计算机专业就好像是一辆汽车。我们之前学的课程，譬如C语言，C++这些课程，是在学（基础的）开车技巧，那么从这门课开始，也包括从数据结构这门课开始，就要开始打开引擎盖，仔细研究汽车内部的工作原理了。</p><p>当然啦，开车嘛，还有很多高级的技巧，比如下水道过弯之类的。但我想，如果想掌握高级的驾驶技巧，那驾驶员一定是对汽车的运行原理、引擎的内在特性都非常了解，才能掌控汽车的每一个细节。直线上开得快大家都会，油门踩下去就行了；但要开的稳、开的省油，还得靠老司机对汽车性能的深入掌握。</p><p>这些课吧，在我看来，就是走向老司机的必经之路，绕不开的。</p><p>还拿汽车引擎举例子。还有一门课叫「计算机体系结构」，那它和咱们马上要学的「计算机组成原理」是什么关系呢？我的理解是这样的：「计算机组成原理」是把引擎给拆开了，研究引擎到底是怎么运转的。而「计算机体系结构」则更加深入，比如研究引擎的定量性能、结构优化等等。</p><p>大家看上面的配图，「组成」的原文是「Organization」。其实我觉得若译为「组织」更有味道。「计算机为什么要这样组织的原理」，对吧。</p><hr><p>至于数据结构和算法，信安的同学们已经学了，我也就不班门弄斧了。对于不了解的同学，我做个剧透。咱们在C语课设中用到的「链表」，就是数据结构的一种。</p><p>我的理解是这样的：所有计算机程序，抽象出来无非两种内容：数据和算法。数据呢，既然存在计算机里，是需要各种各样不同的储存乃至运算的方式的，这是数据结构和算法所研究的内容。</p><p>计算机究其本质，（在我看来）就是「计算能力」。虽然我是没什么机会能走上探求本质的道路，但真理无穷又如何？进一步有进一步的欢喜。我不是搞理论研究的料子，也许我们中的许多人都不是，但是还是那句话，这课的知识毕竟是老司机的必备内容。更何况如果要考研呢，对吧？</p><p>值得一提的是，我觉得C++和（一部分）离散数学算是数据结构与算法的先修课程。还记得Dijkstra算法不？</p><p>说到这，推荐两篇我非常喜欢的科幻短篇，都蕴含着穷举的思想（可见没有一个好的算法是多么痛苦）：</p><ul><li>《神的九十亿个名字》，亚瑟·克拉克</li><li>《诗云》，刘慈欣</li></ul><p>另外，我在B站发现过一个很有意思的视频，视觉化动态展现15种排序算法。强力治愈强迫症。百看不厌= =</p><p><a href="http://www.bilibili.com/video/av1039639/" target="_blank" rel="external">15种排序算法演示(720p)</a></p><p>番号是1039639.</p><p>如果课本读不下去的话，不妨看看轻松的书。譬如这样的：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-2-18/50511024.jpg" alt=""></p><p>可能比课本和课件都活泼吧。</p><hr><p>欢迎转发，欢迎关注。能偶尔写点字，真的挺开心的。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/31/my-2015/" itemprop="url">2015朝饼夕拾</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-12-31T21:39:49+08:00" content="2015-12-31">2015-12-31</time></span></div></header><div class="post-body" itemprop="articleBody"><p>去年高三，明年大三。</p><p>多有意思，雨峰同学似是有所感怀。他和跟他同龄的很多人，都已经习惯于按学期划分时间。一年两个学期，学期和学期之间是寒暑假。但如果以年来看呢？似乎很少这样想。往回看，真的是高三；往前看，真的是大三。多么奇妙的时间点呀，雨峰同学从未觉得他的生命流逝的如此之快，他觉得自己正在加速——身旁的时间呼啸而过，却愈发看不清事物。路标一晃而过，雨峰同学知道他看到了路标，但似是只有潜意识看到了——他不得不依靠自己的直觉认路，那是多么迷幻的感觉啊。他模糊地觉得加速度越来越大，加速度的加速度也越来越大，所有的一切都越来越大。</p><p>如果我们所生活的世界是个超现实主义作品，那么什么是现实呢？</p><hr><p>生而有涯，知而无涯。</p><p>我翻看了一下手机相册，从2014年7月（刚刚结束高考）一直到如今。我为何感觉时间过得越来越快了，大概是我自己做的事情越来越少了吧，尤其是最近这三四个月。</p><p>2014年末，15年初，我觉得我干了不少事情，相册为证。我觉得我干的最多的事就是：</p><ul><li>四处转悠。</li></ul><p>走路四处转悠，骑车四处转悠，坐地铁四处转悠，做其他交通工具四处转悠。那时的生活似是比现在丰富和精彩很多。如果有人问我我为什么喜欢拍照片？至少对我自己来说，我拍的照片刻画了我的心境。我看我那时拍的照片，我能感到自己的心情非常活跃，似是感觉不到累，充满乐观。</p><p>如今呢，大概是有点懒了吧，同样是一个学期，同样是四个月，生命的客观长度大概是一样的，但生命的主观长度，区别真是想有多大就有多大。</p><p>我们之中，有些人短寿，有些人长寿，但再怎么千差万别，我们的寿命都处在同一个<strong>数量级</strong>。吾生须臾，且行且珍惜吧。路过一只小明，你问，他是在修今生还是修来世呢？</p><p>知而无涯，我觉得不仅仅是知识，也是对这个世界原貌的探索。</p><p>我想我们人类也是动物，我们都愿意像鸵鸟一样将头埋在沙子里；但正因为我们是人类，我们有勇气将头抬起来，面向那刺眼的阳光而不退缩，决绝地顶住狂暴的大风。因为我们都明白，急湍的激流之后和雪白的峭壁之下，是明天的日子，是自由与美好。</p><hr><p>少谈些主义，多研究些问题。</p><p>少说话，多研究些问题。</p><p>少瞎想，多研究些问题。</p><p>以上就是我对我自己的新年祝愿了，假装(或真正地)在成为一名工程师的旅途上进发。</p><p>是那种真正的工程师；</p><p>是那种真正的旅途。</p><hr><p>不管怎么说，2015年结束了，对于95-96年生的人儿来说，这是生命中多么有趣、多么枯燥、多么辉煌、多么失落、多么开心、多么忧愁、多么充满希望、又多么令人迷惘的一年呀！</p><p>祝大家来年吃饼愉快，</p><p>新年快乐！</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/01/shu-zi-luo-ji-shi-yan-tips-1/" itemprop="url">数字逻辑实验，如何使用键盘</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-12-01T18:43:56+08:00" content="2015-12-01">2015-12-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>开关（SW1-SW16）自然也可以作为输入，但有些情况更适合用键盘输入，比如密码锁，模拟投币等。</p><p>键盘就是试验箱右下角，0-F的圆形按钮。</p><p>在做这次实验之前，我原以为键盘的输入方式和开关类似，即按下为1，松开为0，但实际上不是这样。如果想使用键盘，还需要专门写一段「键盘扫描程序」。</p><p>程序在实验书P48页有写，这里解释一下：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">input [7:0] RL;</div><div class="line">...</div><div class="line">output KB;</div><div class="line">reg KB;</div></pre></td></tr></table></figure><p>RL对应键盘的「列」，从左到右，是第0列到第7列。</p><p>KB对应键盘的「行」，当KB为<code>0</code>时，键盘下面一行可用，即0-7.</p><p>当KB为<code>1</code>时，上面一行可用，即8-F.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	q = 1&apos;b0;</div><div class="line">    q = KB;</div><div class="line">    KB = ~q;</div><div class="line">end</div></pre></td></tr></table></figure><p>这段代码是为了以时钟频率反复扫描上下两行，所以时钟不要选太慢的，比如选8Hz就挺合适。</p><hr><p>RL[7]到RL[0]就是列输入，这些需要自行连线。比如从实验板上，将<code>KP_RL7</code>（在键盘上方）连了pin138，那引脚分配的时候，就将138分配给RL[7].请注意，书上的<code>input [7:0] RL</code>这个名字和实验板上的KP_RL0至KP_RL7类似，不要混淆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	case (&#123;KB,RL&#125;)</div><div class="line">        9&apos;b011111110:	//当按下「0」的时候要做的事</div><div class="line">        9&apos;b011111101:	//当按下「1」的时候要干的事</div><div class="line">        ...</div><div class="line">        9&apos;b111111110:	//当按下「8」的时候要干的事</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        default:		//什么按键也没按下</div><div class="line">    endcase</div><div class="line">end</div></pre></td></tr></table></figure><p>这里的<code>{}</code>是用来将两个数拼接在一起。</p><p>KB就表示行，KB为0的话就是下面一行有效。这些键盘是负有效，按下的时候变0，抬起的时候是1.</p><hr><p>实验板上的接线方式，这里给一个参考</p><p>从<code>KP_RL0</code>到<code>KP_RL7</code>，可连接pin166, 164 162 160 158 143 140 138。当然了，连哪个引脚都可以。</p><p><code>KP_RL0/7</code>旁边的<code>KP SL0</code>中，<code>KB1</code>和<code>KB2</code>接地，连接到实验板上任意写有<code>GND</code>的引脚即可。</p><p><code>KB0</code>需要连接到一个你自定义的引脚上（比如163），然后再引脚分配环节，将pin163分配给<code>KB</code>就可以了。</p><hr><p>如果你的电路设计，只需要用一行键盘，那就不需要写KB的0-1转换了。但是仍然要分配KB0，确保KB0恒为0（或恒为1即，用上边一行。）</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/11/23/cpp-keypoint/" itemprop="url">C++考试重点解析 | 七系</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-11-23T13:06:11+08:00" content="2015-11-23">2015-11-23</time></span></div></header><div class="post-body" itemprop="articleBody"><p>老师发来的考点是下面这些（原文）：</p><ol><li>类的静态成员和友元</li><li>数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</li><li>对象指针与动态内存分配</li><li>派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</li><li>虚基类</li><li>单目和双目运算符重载</li><li>多态程序编写，包括虚函数、纯虚函数以及抽象类</li></ol><p>这篇文章中我把这些知识点过一遍，正好我自己也复习一下…如果有错误还请指出，我进行勘误后再发一版。这篇文章不是一篇系统的知识点回顾，其中有很多我个人的理解，不甚准确，仅供有限的参考。另外，我的C++学的也比较一般，所以也希望能借此机会和大家多交流。</p><p>另外还请注意的是，咱们的课本写的还是挺清楚的，将这些知识点在书上找出来，再看几遍即可。</p><p>##1.类的静态成员和友元</p><p>###1.1关键字</p><ul><li>静态成员：static</li><li>友元：friend</li></ul><p>###1.2静态成员<br>定义：如果有一个成员，需要和他所属的<strong>类</strong>直接相关，而不是和由这个类生成的<strong>对象</strong>直接相关，此时需要静态成员。</p><p>举例：“北工大学生”作为一个类，可以派生出你，你，你，我，每一个人。而这个类中有一个成员变量“学生总数”，这个成员只和“北工大学生”这个类相关，而不和具体的某个学生对象相关。<br>比如说，“学生总数”这个<strong>成员</strong>，和“王大水”这个<strong>对象</strong>没有关系。</p><p>此时，如果修改任意一个对象中的静态成员，所有派生自同一个类的此静态成员都会同时被改变。也就是说，所有的由此类派生出的对象，都共享同一份静态成员，一变都变。</p><p>使用方法：在成员的声明前加上<code>static</code>。</p><p>比如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>此时，total前的<code>static</code>就是将此变量声明为静态成员的意思。</p><p>当然，<code>static</code>也可以加在<strong>成员函数</strong>的声明前。有什么用呢？比如说，你想在<strong>类还没实例化之前，就修改static变量的值</strong>，那这个修改用的函数也得是<code>static</code>的。</p><p>这块知识基本可以类比Java中学过的<code>Static</code>。</p><p>###1.3友元</p><p>友元的预备知识：访问的控制与封装，即<code>public</code>，<code>protected</code>，<code>private</code>关键字的功能。</p><p>可以这样不严谨但通俗地理解：</p><ul><li><code>public</code>：谁都能来使用我的东西，来者不拒</li><li><code>protected</code>：只有我的孩子孙子（继承自我的类）才能用我的东西</li><li><code>private</code>：只有我自己才能用我自己的东西</li></ul><p>友元的作用，是指定某一个函数(或某一个类的成员函数)“为自己的好朋友”，即可以使用自己的private内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span>;    <span class="comment">//const引用</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//输出信息用的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student stu1;</div><div class="line">    print (stu1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果print是一个用来输出学生对象中信息的函数，那这种方法(加friend)就相当于给了<code>print</code>函数一个特殊的权限。</p><p><code>friend</code>作用在<strong>类的成员函数</strong>时，用法也是一样的。</p><p>友元声明不写在<code>public</code>或<code>private</code>区域中。</p><p>总之，两个类之间需要共享数据的时候，可以使用友元。但请注意，友元实质上破坏了类的封装性。Java中就没有友元函数这一设定。</p><p>##2.数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</p><p>###2.1.数组作为函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * a)</span></span>;  <span class="comment">//声明方法1</span></div><div class="line"><span class="comment">//void sum(int [] a);   //声明方法2，这样也行</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">20</span>];  <span class="comment">//声明数组</span></div><div class="line">    sum (a);    <span class="comment">//传递这个数组为函数参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C语言里学过。形式大概就是上面这样。</p><p>###2.2指针作为函数参数，与地址相关的运算 <code>*</code> 和 <code>&amp;</code></p><p>C和C++语言中，同一个符号在不同的场合会有不同的意思。在和地址相关时：</p><ul><li><code>&amp;</code> ： 取址符</li><li><code>*</code> ： 取值符</li></ul><p>他们俩互为逆运算。<code>&amp;</code>就是取一个变量的地址（通常情况下，也就是指针的意思，但请不要认为地址==指针）。</p><p><code>*</code>的话就是“取一个地址内的值”，和上面的<code>&amp;</code>的操作正好相反。</p><p>就好比说，宿舍号“424”是一个地址，你取424的值，即<code>*424</code>，取出来的就是“王大水”这个值。如果你对“王大水”进行取址，即<code>&amp;王大水</code>，结果就是424.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> * p)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</div><div class="line">    <span class="keyword">int</span> * pointer1 = &amp;a;    <span class="comment">//将a的地址赋给指针pointer1</span></div><div class="line">    func(pointer1); <span class="comment">//指针作为函数参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> * p)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; p;      <span class="comment">//输出的是a的地址，即主函数中的&amp;a</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *p;     <span class="comment">//输出的是a的值，即233</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>##3.对象指针与动态内存分配</p><p>###3.1.对象指针</p><p>如果有一个指针<strong>指向了一个对象</strong>，那这个指针就是<strong>对象指针</strong>了。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student * pb = student1;   <span class="comment">//pb指向了对象student1，pb的类型是"BJUT_Student"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###3.2.动态内存分配</p><p>咱们在C语言里学过<code>malloc</code>，写法比较繁琐，一般是</p><figure class="highlight plain"><figcaption><span>* BJUT_Student = (BJUT_Student*)malloc(sizeof(BJUT_Student));```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在C++里大幅简化了这个功能（申请内存），约等于</div><div class="line"></div><div class="line">```BJUT_Student * student1 = new BJUT_Student();</div></pre></td></tr></table></figure><p>方便多了吧。</p><p>在C++里，尽量使用<code>new</code>，尽量不使用属于C语言的函数(例如<code>malloc</code>)。</p><p>##4.派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</p><p>###4.1.派生类的构造函数和析构函数</p><ul><li>构造函数：用来在新生成一个对象时初始化一些内容</li><li>析构函数：用来执行在销毁一个对象时要做的一些事情</li></ul><p>一般情况下，手写构造函数比较频繁，手写析构函数的机会不多。C++ Runtime 会自动为我们做一些事。</p><p>ps：构造函数在定义的时候，需要和<strong>类名相同</strong>。</p><p>派生类：即从已有的类继承而来的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A     <span class="comment">//基类A</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">int</span> x)&#123;</div><div class="line">        a = x;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    B(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : A(x)  <span class="comment">//派生类的构造函数，冒号后的是“初始化列表”</span></div><div class="line">    &#123;</div><div class="line">        b = y;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是这个意思，B继承自A。派生类的构造函数执行的时候，先执行父类的构造函数，也就是说<strong>初始化列表</strong>中的<code>: A(x)</code>.</p><p>析构函数也和类同名，但前面加了一个<code>~</code>，例如<code>~B(){//xxxxx}</code>。上述代码中没写析构函数。</p><p>派生类中的析构函数，执行的时候和构造函数的顺序相反，即先析构自己，再析构父类。<strong>除非</strong>父类的析构函数是虚函数(virtual)。</p><p>我还从来没实际用过析构函数，所以对这块不了解。一般情况下，对象销毁的时候，系统都自动为我们执行很多相当于析构函数的工作了。</p><p>关于“初始化列表”，可以简单的说：能用初始化列表的场合，都尽量使用初始化列表。尤其是，当某些const类型和引用类型的成员变量需要被初始化时，必须使用初始化列表，因为const或引用变量无法被复制（除初始化时）。</p><p>##4.2.复制构造函数</p><p>就我所知，一般在</p><ul><li>将对象作为参数传递，且为<strong>值传递</strong>的时候需要用到复制构造函数。</li><li>return一个对象。</li><li>纯粹复制一个对象。</li><li>构造一个对象时需要复制另外一个对象。</li></ul><p>说白了就是用来复制一个对象用的函数。关于值传递和地址传递的区别，可以参考我之前写过的文章。</p><p>复制构造函数的写法：一个<strong>参数为类的引用</strong>的构造函数，参数最好是const。例如：</p><p>复制构造函数在本质上还是构造函数，区别在于参数不同，用途不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B(<span class="keyword">const</span> B&amp;);    <span class="comment">//复制构造函数的声明</span></div><div class="line"></div><div class="line">B:B(<span class="keyword">const</span> B&amp; p)&#123; <span class="comment">//复制构造函数的定义</span></div><div class="line">    b = p.b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我的理解是：复制构造函数，就是一个明确指定“如何复制一个对象”的函数。</p><p>#4.3.派生类成员的标识与访问</p><p>不明白这是在说啥…</p><p>#5.虚基类</p><p>即在继承一个类的时候，在被继承的类名前面加个virtual。这在多继承时才会被用到。是为了消除二义性。</p><p>比如有基类A，B继承自A，C继承自A，又有D多继承自B和C。此时D中继承自A的成员，到底是哪一个A呢？（因为B和C分别复制了一份A的成员）这就产生了冲突。</p><p>如果在B和C继承A的时候，将A声明为<strong>虚基类</strong>即可解决这个问题，虚基类会确保A中的成员有且只有一份，D调用的时候就不会产生冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    A a;</div><div class="line">    B b;</div><div class="line">    C c;</div><div class="line"></div><div class="line">    a.i = <span class="number">1</span>;</div><div class="line">    a.print();</div><div class="line"></div><div class="line">    b.i = <span class="number">2</span>;</div><div class="line">    b.print();</div><div class="line"></div><div class="line">    c.i = <span class="number">3</span>;</div><div class="line">    c.print();</div><div class="line"></div><div class="line">    D d;</div><div class="line">    d.i = <span class="number">4</span>;    <span class="comment">//消除了二义性，如果不用虚继承，此处编译出错</span></div><div class="line">    d.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虚基类这事儿不常用。可以参考Java语言：根本就没有多继承，所以也不用操心这些事儿。</p><p>注：在Java中，和「多继承」类似的功能一般靠接口(interface)实现。</p><p>##6.单目和双目运算符重载</p><p>运算符重载是C++的一个特点，另一门面相对象语言即Java中，就没有运算符重载。因为他们的设计哲学有区别吧。</p><p>之前咱们学过函数的重载，即，当函数名相同，但函数参数列表不同时，程序会根据咱们实际所给的参数列表，动态地选择应调用的函数。</p><p>运算符重载也差不多，经过重载，同样地运算符在参与不同的数据类型（比如：int，double 就是两种不同的数据类型），会有不同的表现。</p><p>这是双目运算符的重载：(课本P310)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">Complex::<span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> Complex(<span class="keyword">this</span>.real + c2.real, <span class="keyword">this</span>.imag + c2.imag);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在双目运算符的重载中，运算符左边的操作数就是this。this一般可以省略。右操作数作为参数传递进来，也就是说这里的c2.</p><p>为什么需要重载这个加号呢？因为<code>Complex</code>类型是用户自定义的类型，C++编译器不知道该如何将两个这样的对象“加”在一起，需要用户手动描述。</p><p>单目运算符的重载也是一个意思。比较常用的单目运算符重载是<code>++</code>,<code>--</code>，值得注意的是，单目运算符重载一般没有参数（被运算的数作为this指针隐式传递）。</p><p>还有一种情况，即用友元函数进行运算符重载，这样的话，双目运算符重载就有两个参数，单目运算符重载就有一个参数。因为友元函数运算符重载没有this指针。</p><p>关于自增运算符前置、后置的重载，可以参考课本P312，非常清楚。</p><p>##7.多态程序编写，包括虚函数、纯虚函数以及抽象类</p><p>###7.1.多态，虚函数</p><p>什么是多态呢…</p><p>书上的定义不太好理解，一般都是类似于“对同一个消息作用在不同的对象上，会产生不同的效果”。你可能会问，这不是废话吗？比如有个父类Animal，子类Dog，我让Animal“吃”，和让Dog“吃”，效果肯定不一样啊，这还用系统给我判断？</p><p>你说的没什么错。按照我的理解，什么时候需要多态性呢？</p><p>比如有个<code>Animal</code>类型的指针<code>a</code>，这个指针<code>a</code>指向<code>Animal</code>的时候，你调用<code>a.eat()</code>。指针再指向<code>Dog</code>的时候，你又调用<code>a.eat()</code>。此时如果能分别正确调用<code>Animal</code>和<code>Dog</code>的<code>eat()</code>方法，那这就是多态。</p><p>如果你分别用指向<code>Animal</code>和指向<code>Dog</code>的指针，分别调用<code>eat()</code>，这就不叫多态。</p><p>多态这件事和<strong>继承</strong>是<strong>紧密相连</strong>的。</p><p>咱们应该是都学过Java了，为啥Java中没怎么提到过多态呢？确实如此，因为Java中的类的继承，在默认的情况下就已经实现了多态了。</p><p>但C++就没这么自动化，如果想让一个父类的某个成员函数能实现多态性，就必须规定这个函数为<code>虚函数</code>。</p><p>用刚才那个例子来说，也就是说得让Animal类中的eat()方法前加上一个virtual。类似：</p><figure class="highlight plain"><figcaption><span>void eat()&#123;//xxx&#125;;```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###7.2.纯虚函数</div><div class="line"></div><div class="line">纯虚函数是一种特殊的虚函数。即只声明，不实现定义。由继承下去的子类去具体实现。</div><div class="line"></div><div class="line">写法是这样：</div><div class="line"></div><div class="line">```virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</div></pre></td></tr></table></figure><p>加了一个<code>=0</code>。注意,<code>virtual</code>也不能少。</p><p>我个人理解：纯虚函数对应Java中的抽象(Abstract)函数。</p><p>###7.3.抽象类</p><p>只要是包含了纯虚函数的类就自动被归为抽象类。和Java中的抽象类类似，不能被实例化为对象，只能被继承。</p><p>抽象类中至少存在一个纯虚函数；存在纯虚函数的类一定是抽象类。存在纯虚函数是成为抽象类的充要条件。</p><h2 id="完毕。"><a href="#完毕。" class="headerlink" title="完毕。"></a>完毕。</h2><p>C++的确很有用，非常强大，效率很高。坦诚地讲，也很有学习的必要。但从我个人的角度，以及我目前对C++及其浅薄的认识，我不是很喜欢C++这门语言给我的感觉。强类型的面向对象语言中，我更喜欢Java。目前我正在(以极其缓慢、肉眼几乎难以辨别的速度)学习Python，如果有同感兴趣的朋友请一起来交流。</p><p>当然了，我想强调的是，我承认C++作为<strong>基石</strong>的作用。我也同意，作为计算机专业的学生，有必要对C++进行相对深度的学习。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/10/27/DC-regulated-power/" itemprop="url">直流稳压电源(电路实验1)笔记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-10-27T17:38:05+08:00" content="2015-10-27">2015-10-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>电子实验的第一个实验，「直流稳压电源」。由于实验小册子上的图和文字实在是太抽象、太魔性了，我把我对这个电路的一些认识写在这里，供参考。如果写错了内容并对你的电路(和心理)造成了不可逆转的伤害，我请你吃冰棍。</p><p>另外，我的器件包里没有任何<strong>电阻</strong>，但 @辛德龙 就有俩氪金彩色电阻，大家都有电阻吗？</p><p>#认识元器件</p><p>元件和器件是有区别的。在我看来，电阻、电容这类比较基础的东西就是「元件」，差分放大器、集成电路的话就算「器件」</p><p>##电解电容（大）<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/82966437.jpg" alt=""></p><p>1000μF</p><p>和整流桥并联。</p><p>给转换出的直流电做滤波(?)和稳压(?)用的，总之是个缓冲作用。这个电路上大多数的电容都是缓冲作用。</p><p><strong>听说这个电容接反的话会爆炸。</strong>，有白条的一侧就是负极。同时，引脚长的一侧为正极。</p><p>这个黑色电解电容，从包装来看是Rubycon牌子的，我上网查了一下，怀疑是假货。</p><p>##电解电容（小）</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/62548616.jpg" alt=""></p><p>数量若干。</p><p>##陶瓷电容</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26675224.jpg" alt=""></p><p>这种电容不用分正负。听说也不会爆炸？</p><p>##整流桥</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/24418714.jpg" alt=""></p><p>能将交流电转为（<em>不那么平整的</em>）直流电。大约是1V交流电（有效值）能转为1.2V直流电。</p><p>看印刷，<strong>两个「~」接交流电，「+」和「-」就是直流输出</strong>。</p><p>其实就是小册子上的这玩意：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/46572702.jpg" alt=""></p><p>因为这个整流桥的内部就是封装了4个二极管。</p><p>##二极管</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/73668153.jpg" alt=""></p><p>型号：1N4007</p><p><strong>有白环的一侧为负极</strong>。在咱们这个电路中，接在7805的1，3引脚之间，保护用。引脚3接二极管正极。</p><p>##稳压器</p><p>型号可能是「LM7805」</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/16602044.jpg" alt=""></p><p>从印刷字的一侧看，<strong>左起为引脚1，2，3</strong>。1接正极，3接输出，2接地。</p><p>由于经过整流桥整流过的直流电，还不是很平整（参考上面整流桥的波形图），这个7805就是撸平电流用的，作用类似电熨斗。</p><p>这个7805稳压器能稳定输出5V直流电源，输入的话一般在7-10V。那这几V的电去哪了？被这个器件变成热量了。上面的那个孔，就是接散热片用的。不过咱们这个电路电流不大，我估计不需要散热片。</p><p>##功率放大器</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26540379.jpg" alt=""></p><blockquote><p>图：百度图片</p></blockquote><p>其实已经不是「直流稳压」部分的功能了。估计是为了驱动喇叭。</p><p>咱们给的是「386D」，和「LM386」的原理基本一样，应该是生产的厂商不一样。</p><p>有圆形凹陷的那个角，是引脚1（所有器件都这样）。引脚图：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/76078863.jpg" alt=""></p><blockquote><p>图：JRC的器件手册</p></blockquote><ul><li>引脚1，8：接一个电容，调节用</li><li>引脚2：反相输入（信号源）</li><li>引脚3：正相输入（信号源）</li><li>引脚4：接地</li><li>引脚5：输出信号</li><li>引脚6：电源（在咱们这个实验中就是7805给的5V直流）</li><li>引脚7：旁路（接一个电容，电容再接地。好像是对输出信号的稳定有好处）（去耦?）</li></ul><p>反相和正相输入，大概就是咱们电路课正在学的功率放大器吧。</p><p>##管脚座(?)</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/30867599.jpg" alt=""></p><p>386一定要插在管脚座上，将管脚座焊接在电路板上。我不确定是不是叫「管脚座」这个名字。</p><p>建议7805也接在座上，毕竟听说<em>电烙铁可能会焊坏器件（给的热量太多）</em></p><p>#电路图</p><p>小册子上的图太魔性了简直。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/43741313.jpg" alt=""></p><p>感谢 @曾檬 @孙昀淏 分享图片，拯救我于水火之中。此图建议大家存好，你懂得。</p><p>#总之<br>想搞一个8Ω小喇叭，没搞来。</p><p>焊锡就给那么点，器件焊坏了还不给分，这真的是实验课？这让人怎么练手？非得让人缩手缩脚？一个器件有几块钱？我出钱买还不行吗？焊坏一个器件就不给分？</p><p>##接地是啥意思？</p><p>我理解接地，就是接「低电平」的意思，在咱们这个电路中，唯一可行的低电平就是电源负极。也就是说接地就是接电源负极的意思。</p><p>没必要接大地。</p><p>##一些笔记</p><ul><li>防止输入对地短路</li><li>防止输入输出接反</li><li>防止输入滤波电路短路（大概会爆炸？）</li><li>防止输出与高电平接（大概会烧坏器件）</li><li>防止三 - 地 - 开路 （原文如此，我也忘了记的是啥意思了，求解）</li></ul><p>##总之</p><p>这个电路：</p><ol><li>将交流电，用整流桥（扁平圆柱，四脚），变成不平整的直流电</li><li>将不平整的直流电，用稳压器（7805，三脚），变成平滑的5V直流电</li><li>用5V的直流电驱动功放（386D，八脚）</li></ol></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/26/programming-language/" itemprop="url">都有啥编程语言？</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-26T20:05:26+08:00" content="2015-09-26">2015-09-26</time></span></div></header><div class="post-body" itemprop="articleBody"><p>编程的语言多种多样，那么编程语言都有哪些呢？</p><p>本期栏目会根据2015年9月TIOBE的排行榜，对当下排名前20的编程语言做一个<em>非常简单</em>的阅览，以后再展开细说。对编程语言的介绍，由于王大水同学孤陋寡闻，难免存在错误，还请大家指出。</p><blockquote><p>TIOBE是一个编程语言的流行度排行榜，每月出一期。这个排行榜只能在一定程度上反映编程语言的流行程度，并不代表某种编程语言更好，没必要过度解读。</p></blockquote><p>#2015年9月排行<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-26/21170782.jpg" alt=""></p><p>其实也就前十左右还算是「主流」的编程语言。</p><p>#Java</p><p>Java语言很牛。近十多年来，Java基本上一直雄踞TIOBE榜首。</p><p>Java语言在刚面世的时候（1995年）心气非常大。Java想统一所有的平台，设计者的意思是，「有Java就足够了，其他编程语言都是渣渣」。虽然如今Java并没有这么万能，不过也是很厉害了。Java在企业后台开发、网页后端、Andriod开发、云计算、大数据等领域需求都很大。</p><p>Java是非常成熟的面向对象语言，Java宣称「Java语言中的一切都是”对象”」（虽然并不真正如此）。相比C++语言来说，Java是一个更加纯粹的面向对象语言。Java舍弃了很多『危险』的设计，比如指针、比如不让程序员手动操作内存。Java语言的安全性非常不错（相比C++和C），但在效率上就有所牺牲。</p><p>学Java的过程，相比学习C语言，是<em>非常</em>幸福的事情。</p><p>咱们计算机系的话，一般都是会学Java的。我的个人建议是，体会面向对象的初步思想，这是关键。要明白「继承」、「对象」、「类」这些概念的准确意思。因为任何面向对象语言中，这些东西都是想通的。至于Java语言的语法细节，或者Java的图形库等等细节的东西，不用抠太细了。</p><p>啰嗦一下，<strong>最好别用学文科的方法学编程。</strong></p><blockquote><p>名词解释</p><ul><li>Java SE。就是咱们平时学Java时所用的Java库的版本。如果大家有玩过「Minecraft」的话，应该还记得在运行MC之前必需安装Java，因为MC就是用Java编写的。你问为何Windows操作系统不自带Java？哈，他们两家公司的恩怨情仇回头还能细说。</li><li>Java EE。企业开发用的Java，不懂。</li><li>Java ME。M是Micro的意思，一般在单片机版之类的地方用，似乎已经没什么人在用了。</li></ul></blockquote><p>#C</p><p>就是咱们正在学的C语言。这算是老前辈了（1972）年，因为C既有「<em>高级</em>程序设计语言」的特点，又能操纵硬件层面的细节，所以很受程序员欢迎。</p><p>但是C语言是面向过程的语言，而且C语言中的「指针」「手动内存管理」等特性容易造成BUG，所以如今C语言用的已经不是太多了。但是毕竟是有用的，比如Linux(一种操作系统)大多数的代码由C语言构成。写单片机、数值计算领域，C语言还是用的很广泛的。</p><p>#C++<br>也是老牌面向对象语言了。我想出过一个比喻，我觉得用来形容C++语言还是挺恰当的。</p><p>「C++语言是一艘航空母舰，攻击力强大。但烧煤的发动机拖累了它。」</p><p>啥意思呢？C++语言在设计的时候，为了兼容C语言，便设计为「C语言的超集」，也就是说C++完全向下兼容C语言（从这门语言的名字也能看出来这一点）。这样一来，C++就背上了沉重的历史包袱。</p><p>比如为什么咱们能在「Visual C++」这个软件中编写C语言呢？就是这个意思。</p><p>#C井</p><p>「C#」，<strong>读做「C sharp」</strong>。就是「C 升号」的意思。（变相表达C”++“）</p><p>我猜测，如果读「C井」的话，只要读满65535次，有一定几率下辈子投胎M78星云。</p><p>C#是微软公司出品的一款编程语言，其实就是模仿Java整出来的一款竞品。C#我没接触过，听说很好用，很好学，很强大。很多桌面程序都是用C#写的。</p><p>说白了，你要是Java学得好，C#分分钟就会了。</p><p>#Python</p><p>Python可火了，啥都能干。Python语言相对优雅，相对速度还不错，相对易于学习。很多国外的大学，计算机专业的入门语言便是Python。听说国内有少数大学也在尝试用Python作为第一门编程语言。</p><p>数值计算、网站后端、脚本、还有今天特别火的大数据、机器学习啥的，Python好像都有份。</p><p>Python语言的特点之一是强制要求你使用规范的代码缩进。</p><p>#PHP</p><blockquote><p>「PHP」是世界上最好的编程语言。——PHP程序员</p></blockquote><p>PHP主要是在CGI（即网站后端）用途广泛，是一门非常经典的服务器后端语言。语法和C比较接近。</p><p>#JavaScript</p><blockquote><p>「Java」和「JavaScript」的关系，就如同雷锋和雷峰塔的关系。——知乎用户</p></blockquote><p>JavaScript的名字中为啥有个Java呢？可以这样简单理解：JavaScript的设计者抱Sun公司（开发Java的公司）大腿。</p><p>Javascript如今也是越来越火了，有前后端通吃的气势。</p><p>由于当初设计Javascript的人是个「Lisp」语言脑残粉，所以Javascript中的面向对象特性特别难用。但是毕竟人家已经成为了连接网站前后端的唯一语言了，几乎没有竞争对手。所以值得接触一下。</p><p>#Visual Basic .NET<br>名词解释</p><ul><li>Visual Basic，即VB。似乎很多人之前就接触过，就是拖一个个控件，然后就能做出个还算好看的程序。</li><li>.NET，我的理解是：微软的一整套东西，合在一起叫.NET。</li></ul><p>我觉得「Visual Basic .NET」就是咱们平时说的VB。</p><p>倒是一门不错的教学语言。我之前还真用Excel中的VB写了一个「生命游戏」，有兴趣请看我Github。</p><p>#Perl</p><p>没用过，似乎是一种处理字符串非常强大的语言。比如说，Perl内置了「正则表达式」，而正则表达式用来处理字符非常厉害。</p><p>似乎Perl和Linux/Unix结合使用的情况比较多。</p><p>这也是一门有年头的语言了，大概是20世纪80年代推出的。</p><p>#Objective-C</p><p>其实也挺老了，本来都快要退出历史舞台了，但正好Apple公司选了了Obj-C语言作为平台开发语言，所以又火了。</p><p>不过今天Apple公司也使用新的Swift语言了。不知道Objective-C何去何从。</p><p>#Assembly language</p><p>就是「汇编语言」的意思。</p><p>汇编语言是一种介于「机器语言」（01二进制代码）和「高级语言」（比如C语言）之间的一种语言。</p><p>恩…不知道什么人还在用。也许是写底层程序和驱动的吧。</p><p>#Ruby</p><p>如果说Ruby语言没有汇编语言流行，打死我也是不会信的。所以说这个排行榜看看就好。</p><p>Ruby是源自日本的一种编程语言，在网站开发方面非常流行。Github这个社区，最早就是Ruby程序员爱好者建立起来的。</p><p>#Delphi</p><p>听说这门语言在数据库方面用的比较多，「Dev-C++」这款软件也是用Delphi写的。</p><p>不过据我所知，Delphi已经基本退出历史舞台了。Delphi的前身是Pascal。</p><p>#Visual Basic</p><p>不知道这和Visual Basic .NET有啥区别。</p><p>#Pascal<br>想当年这也是挺火的语言。</p><p>我初中的时候，比如NOIP竞赛，Pascal和C语言还是并列的关系。他们都是经典的面向过程的语言。在我的指导老师上学的时候，Pascal是必修课，C语言是选修课。可见Pascal昔日的辉煌。</p><p>这门语言的名字是为了纪念数学家「帕斯卡」。帕斯卡发明了「加法器」，可谓是人类历史上的第一个「计算机器」。</p><p>也已经退出历史舞台了。</p><p>#Swift</p><p>Swift就是现在Apple公司力推的开发语言。Apple Store里的那些App，如今应该有好多已经是Swift写的了。</p><p>#MATLAB</p><p>一种主要用于数值计算的软件。但Matlab能干的事儿远不止数值计算，比如算法开发、数据可视化、数据分析、建模仿真等等，都能干。</p><p>更纯粹的数值计算软件是「Mathematica」，还有个同类的软件叫「Maple」。</p><p>#PL/SQL</p><p>PL/SQL是「过程化SQL」的意思，是「Oracle」（即甲骨文）公司独有的。如今Java语言的版权便归属于Oracle。</p><p>SQL是「结构化查询语言」的意思，在数据库中有非常广泛的应用。</p><p>#R</p><p>是一种统计领域中使用较多的语言。比如学经济/金融的同学，或者搞数学建模的同学，大概会接触到R语言吧。</p><p>#COBOL</p><p>这是一个20世纪60年代就有的语言。在企业/银行的数据管理中运用广泛。</p><p>#小结</p><p>有一种说法：一个好的计算机专业毕业生，应该掌握</p><ul><li>一门面向过程的语言</li><li>一门面向对象语言</li><li>一门脚本语言</li></ul><p>如果学有余力，最好</p><ul><li>对函数式语言有所了解</li></ul><p>打个比方，如果我毕业的时候熟悉C、Java和Python，对Scala有一定了解，就算是符合这个条件了。</p><hr><p>这个榜单一直排了50种编程语言。后边的语言，有些是应用的领域非常小，有些则是历史遗留产物了。</p><p>值得一提的是，排名第48的编程语言是「VHDL」，眼熟吗？</p><p>谢谢@刘鑫学长的提醒，数字逻辑这门课要学的是 Verilog HDL，和VHDL还是有些区别。不过他们能干的事儿都差不多。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person"><img class="site-author-image" itemprop="image" src="http://7xku3h.com1.z0.glb.clouddn.com/alanwang.png" alt="Alan"><p class="site-author-name" itemprop="name">Alan</p><p class="site-description motion-element" itemprop="description">Alan Wang's personal blog.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></div></nav><div class="links-of-author motion-element"></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2016</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Alan</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script></body></html>