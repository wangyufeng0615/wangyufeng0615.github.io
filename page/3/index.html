<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><meta name="description" content="Alan Wang&apos;s personal blog."><meta property="og:type" content="website"><meta property="og:title" content="王雨峰的博客"><meta property="og:url" content="http://wangyufeng.org/page/3/index.html"><meta property="og:site_name" content="王雨峰的博客"><meta property="og:description" content="Alan Wang&apos;s personal blog."><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="王雨峰的博客"><meta name="twitter:description" content="Alan Wang&apos;s personal blog."><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://wangyufeng.org/page/3/"><title>王雨峰的博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">王雨峰的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">为互联网贡献一些比特。</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2016/03/29/2016-3-29/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/29/2016-3-29/" itemprop="url">三月末</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-29T16:20:57+08:00">2016-03-29</time></span></div></header><div class="post-body" itemprop="articleBody"><p>工大校园中，有两棵树我特别喜欢。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/73594368.jpg" alt=""></p><p>(图文无关)</p><p>一颗是旧图门口右手边的那棵树，大概是玉兰吧。开花时香气沁人，而且不仅仅是清香——还有种略微刺激鼻腔的浪漫气味，令人迷醉。人们为此驻足，花香似是热情地诱惑着路人前来学习；又是温柔的奖赏，给那些闭馆时走出图书馆的同学，花香就着月光，让人爱上了春天的热情。</p><p>另一颗树比较隐蔽，是在学生活动中心(团委楼)的东北角，去澡堂的路上可以看到。这棵树开出的花漂亮极了，零零碎碎的白色小花，精致而优雅，没什么气味。花都很小，就着些黄黄绿绿，遮挡不住什么视线，人们尽情地看，她也不会害羞。这棵树两面都是墙，路人匆匆而过，这树没什么存在感——就那样安静地待在那里，亭亭玉立。似是为自己绽放，展示着春天的优雅。</p><p>我想了想，我爱的不是这两棵树，而是这两棵树的花。我觉得他们的花期特别短，往往是下面的花正卯足了劲绽放，上面的花已经感到疲倦，开始往下落了。等再过一个月，花瓣没入尘土，嫩绿的树叶长了出来，大家就都一样了。日复一日的光合作用，使他们运动，使他们变化。如果植物有信仰，太阳一定是他们的神。</p><p>我喜欢树多的地方。有一回，我爬上四教的天台，仔细观察了一下校园中树多的地方，发现有三处。一是北研楼南侧，二是数理楼和教材科之间，三是一教南侧的大林子。还有一排树我也喜欢，就是一号楼南侧的这排——我不知道是不是杨树。这些树很高，高度超过一二号宿舍楼，当树叶都长出来后，给人一种身处树中的幻觉，很是舒适——大概是我儿时对树屋的梦想吧。我现在正坐在宿舍窗边打下这些字，离我咫尺之遥的地方，就是一支伸向我们窗户的树杈，挂着几颗类似花苞的东西，嫩绿嫩绿的，但不是花苞，因为我知道他将开出的是翠色的树叶。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/26780150.jpg" alt=""></p><p>树杈在微风中轻轻摇曳，像是要努力表达什么。我尽力伸出手，但不踮脚就够不到。那距离啊，让我想起了一幅画。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-3-29/15240006.jpg" alt=""></p><p>那我们中谁是耶和华？大概是树吧。我觉得从进化的角度来看，树是种相当成功的物种了，比我们人类，比动物，都更成功。毕竟树没什么欲望，假如有欲望我们也无从知晓。他们静静地开花，静静地繁衍，静静地活着。</p><p>我喜欢春天，春天是属于生命的季节，春天是生命力的代言人。曾经一到春天，我还会觉得有些中二的忧伤——春天到了，夏日的狂欢结束后，就是秋天的萧瑟，冬日的肃杀，令人悲伤啊真是。去年这时候，我整个人都非常有活力，搬着相机四处拍照，四处骑车专走野路，四处爬天台，在天台上默念”I’m the king of the world.” 因为我脸皮薄，所以不敢喊出来。今年我平静的多了，也许这就是成长？也许人走入奔三的轨道后，就逐渐丧失了好奇心和热情？我说不好。谁知道呢，让我自己慢慢琢磨吧。先把手头的事弄好，就已经是对得起这春天的太阳了。</p><p>万物生长靠太阳。万物开始生长的三月要结束了，紧接着是万物持续生长的四月。</p><p>感恩太阳！</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2016/03/08/alpha-go/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/03/08/alpha-go/" itemprop="url">AlphaGo vs. 李世石，见证历史</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-08T19:55:48+08:00">2016-03-08</time></span></div></header><div class="post-body" itemprop="articleBody"><p>明天（3月9日），「人机大战」就要来了。围棋人工智能 AlphaGo 和世界冠军李世石的第一场比赛将于明天打响。网上有多家媒体进行直播，大家不妨关注。</p><p>小时候，我只是隐约听说过卡斯帕罗夫和「深蓝」的那场世纪大战，但却没有什么感受，只是知道「哦，人工智能很厉害，赢了象棋大师」。随着年龄的累加和计算机专业的学习，愈发觉得1997年那场比赛的分量之厚重。1996年，卡斯帕罗夫对垒「深蓝」，以4：2赢得了首战；1997年的重赛中，卡斯帕罗夫以2.5:3.5落败。这次重赛的意义我难以详述，大家如果感兴趣，不妨在网上浏览一下。有意思的是，「深蓝」的设计师叫徐峰雄，和 Facebook 的围棋人工智能一样，设计师都是华人。</p><p>我的QQ网名也叫「深蓝」，有人问过我，这名字是不是指这台计算机？是也不是，因为我确实喜欢深蓝色 :)</p><p>大约是1998年我接触到计算机（一台80286，感谢我的父母），自然不知道也不懂1997年的这件大事。但是这次不同了，上天给了我们一次见证历史的机会。</p><p>这篇文章的标题是「见证历史」，但如果AlphaGo输了，那还见证个啥呢？（笑）</p><p>随着第一战越来越近，各路专业人士也发表了自己的看法。我大致总结了一下：</p><p>围棋选手，基本看好李世石，主流意见是李世石占有压倒性的优势。<br>「我是看好李世石5-0胜，我认为没有别的比分，如果出现别的比分，那么我认为都是商业行为。」中国国家围棋队总教练俞斌如是说。这是比较极端的一类表态。</p><p>人工智能专家，基本看好 AlphaGo，主流意见是双方水平伯仲之间，AlphaGo胜率略大。<br>也许一些人工智能专家已经是在保守表态了，毕竟 AlphaGo 是追赶者、挑战者。挑战的是我们人类对自身智力的骄傲。</p><p>当然，也有学者认为 AlphaGo 会完胜李世石。</p><p>我觉得这次 AlphaGo 应该会全力以赴，毕竟 Facebook 的围棋 AI 也蓄势待发，万一 First Blood 被 Facebook 拿了呢？</p><p>各路表态中，李开复老师的意见较为和谐，认为 AlphaGo 本次胜算不大，但未来1-2年内定会完成超越。我将文章附在下面，转自知乎上李开复老师的回答。</p><p>另外，我相信 AlphaGo 会赢，我也希望它赢。我觉得，哪怕李世石输了，哪怕所有围棋的顶尖高手都输了，这并不是对人类智慧的羞辱，这正是令人类的智慧熠熠发光的大好机会。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2016/02/18/new-term/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/02/18/new-term/" itemprop="url">聊聊新学期的两门课</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-18T20:34:19+08:00">2016-02-18</time></span></div></header><div class="post-body" itemprop="articleBody"><p>又开学了。</p><p>这是我们人生中的第28次开学。也许你会多个一两次，少个一两次。不过一样的是，又还剩下多少次呢？</p><p>一眨眼的功夫，大学就过去一年半了。不论是充实、迷茫，快意还是踟蹰，有句话说在当下，我觉得挺应景：</p><p>悟以往之不谏，知来者之可追。</p><p>共勉。</p><hr><p>计科下学期开「数据结构」和「计算机组成原理」，其他专业不了解。我对这两门课也没啥了解，只是聊聊我的看法，希望大家能借此多多交流。</p><p>这两门课都是计算机专业的支柱课程。虽然，从理论上来说，我们学的所有知识都是「有用的」，但我也想说，计算机组成原理的作用，怕是要比电路与模拟电子技术没准儿稍微大那么一点点。</p><p>咱们上学期学了「数字逻辑」这门课，我翻了一下咱们下学期要用的教材，感觉数字逻辑算是计算机组成原理的先修课程。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-2-18/40684185.jpg" alt=""></p><p>咱们大概就是用这门书。这书的附录B，专门是补数字逻辑的内容。上学期学数字逻辑的时候，我有个简单的问题一直没想明白，还以为是自己理解能力实在不行。看着附录突然就明白了。哎。要不然怎么好多人都说尽量读经典教材。</p><p>这书的目录非常有意思，我翻了翻，给我的感觉是这样的：如果说计算机专业就好像是一辆汽车。我们之前学的课程，譬如C语言，C++这些课程，是在学（基础的）开车技巧，那么从这门课开始，也包括从数据结构这门课开始，就要开始打开引擎盖，仔细研究汽车内部的工作原理了。</p><p>当然啦，开车嘛，还有很多高级的技巧，比如下水道过弯之类的。但我想，如果想掌握高级的驾驶技巧，那驾驶员一定是对汽车的运行原理、引擎的内在特性都非常了解，才能掌控汽车的每一个细节。直线上开得快大家都会，油门踩下去就行了；但要开的稳、开的省油，还得靠老司机对汽车性能的深入掌握。</p><p>这些课吧，在我看来，就是走向老司机的必经之路，绕不开的。</p><p>还拿汽车引擎举例子。还有一门课叫「计算机体系结构」，那它和咱们马上要学的「计算机组成原理」是什么关系呢？我的理解是这样的：「计算机组成原理」是把引擎给拆开了，研究引擎到底是怎么运转的。而「计算机体系结构」则更加深入，比如研究引擎的定量性能、结构优化等等。</p><p>大家看上面的配图，「组成」的原文是「Organization」。其实我觉得若译为「组织」更有味道。「计算机为什么要这样组织的原理」，对吧。</p><hr><p>至于数据结构和算法，信安的同学们已经学了，我也就不班门弄斧了。对于不了解的同学，我做个剧透。咱们在C语课设中用到的「链表」，就是数据结构的一种。</p><p>我的理解是这样的：所有计算机程序，抽象出来无非两种内容：数据和算法。数据呢，既然存在计算机里，是需要各种各样不同的储存乃至运算的方式的，这是数据结构和算法所研究的内容。</p><p>计算机究其本质，（在我看来）就是「计算能力」。虽然我是没什么机会能走上探求本质的道路，但真理无穷又如何？进一步有进一步的欢喜。我不是搞理论研究的料子，也许我们中的许多人都不是，但是还是那句话，这课的知识毕竟是老司机的必备内容。更何况如果要考研呢，对吧？</p><p>值得一提的是，我觉得C++和（一部分）离散数学算是数据结构与算法的先修课程。还记得Dijkstra算法不？</p><p>说到这，推荐两篇我非常喜欢的科幻短篇，都蕴含着穷举的思想（可见没有一个好的算法是多么痛苦）：</p><ul><li>《神的九十亿个名字》，亚瑟·克拉克</li><li>《诗云》，刘慈欣</li></ul><p>另外，我在B站发现过一个很有意思的视频，视觉化动态展现15种排序算法。强力治愈强迫症。百看不厌= =</p><p><a href="http://www.bilibili.com/video/av1039639/" target="_blank" rel="noopener">15种排序算法演示(720p)</a></p><p>番号是1039639.</p><p>如果课本读不下去的话，不妨看看轻松的书。譬如这样的：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/16-2-18/50511024.jpg" alt=""></p><p>可能比课本和课件都活泼吧。</p><hr><p>欢迎转发，欢迎关注。能偶尔写点字，真的挺开心的。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/12/31/my-2015/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/31/my-2015/" itemprop="url">2015朝饼夕拾</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-31T21:39:49+08:00">2015-12-31</time></span></div></header><div class="post-body" itemprop="articleBody"><p>去年高三，明年大三。</p><p>多有意思，雨峰同学似是有所感怀。他和跟他同龄的很多人，都已经习惯于按学期划分时间。一年两个学期，学期和学期之间是寒暑假。但如果以年来看呢？似乎很少这样想。往回看，真的是高三；往前看，真的是大三。多么奇妙的时间点呀，雨峰同学从未觉得他的生命流逝的如此之快，他觉得自己正在加速——身旁的时间呼啸而过，却愈发看不清事物。路标一晃而过，雨峰同学知道他看到了路标，但似是只有潜意识看到了——他不得不依靠自己的直觉认路，那是多么迷幻的感觉啊。他模糊地觉得加速度越来越大，加速度的加速度也越来越大，所有的一切都越来越大。</p><p>如果我们所生活的世界是个超现实主义作品，那么什么是现实呢？</p><hr><p>生而有涯，知而无涯。</p><p>我翻看了一下手机相册，从2014年7月（刚刚结束高考）一直到如今。我为何感觉时间过得越来越快了，大概是我自己做的事情越来越少了吧，尤其是最近这三四个月。</p><p>2014年末，15年初，我觉得我干了不少事情，相册为证。我觉得我干的最多的事就是：</p><ul><li>四处转悠。</li></ul><p>走路四处转悠，骑车四处转悠，坐地铁四处转悠，做其他交通工具四处转悠。那时的生活似是比现在丰富和精彩很多。如果有人问我我为什么喜欢拍照片？至少对我自己来说，我拍的照片刻画了我的心境。我看我那时拍的照片，我能感到自己的心情非常活跃，似是感觉不到累，充满乐观。</p><p>如今呢，大概是有点懒了吧，同样是一个学期，同样是四个月，生命的客观长度大概是一样的，但生命的主观长度，区别真是想有多大就有多大。</p><p>我们之中，有些人短寿，有些人长寿，但再怎么千差万别，我们的寿命都处在同一个<strong>数量级</strong>。吾生须臾，且行且珍惜吧。路过一只小明，你问，他是在修今生还是修来世呢？</p><p>知而无涯，我觉得不仅仅是知识，也是对这个世界原貌的探索。</p><p>我想我们人类也是动物，我们都愿意像鸵鸟一样将头埋在沙子里；但正因为我们是人类，我们有勇气将头抬起来，面向那刺眼的阳光而不退缩，决绝地顶住狂暴的大风。因为我们都明白，急湍的激流之后和雪白的峭壁之下，是明天的日子，是自由与美好。</p><hr><p>少谈些主义，多研究些问题。</p><p>少说话，多研究些问题。</p><p>少瞎想，多研究些问题。</p><p>以上就是我对我自己的新年祝愿了，假装(或真正地)在成为一名工程师的旅途上进发。</p><p>是那种真正的工程师；</p><p>是那种真正的旅途。</p><hr><p>不管怎么说，2015年结束了，对于95-96年生的人儿来说，这是生命中多么有趣、多么枯燥、多么辉煌、多么失落、多么开心、多么忧愁、多么充满希望、又多么令人迷惘的一年呀！</p><p>祝大家来年吃饼愉快，</p><p>新年快乐！</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/12/01/shu-zi-luo-ji-shi-yan-tips-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/01/shu-zi-luo-ji-shi-yan-tips-1/" itemprop="url">数字逻辑实验，如何使用键盘</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-01T18:43:56+08:00">2015-12-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>开关（SW1-SW16）自然也可以作为输入，但有些情况更适合用键盘输入，比如密码锁，模拟投币等。</p><p>键盘就是试验箱右下角，0-F的圆形按钮。</p><p>在做这次实验之前，我原以为键盘的输入方式和开关类似，即按下为1，松开为0，但实际上不是这样。如果想使用键盘，还需要专门写一段「键盘扫描程序」。</p><p>程序在实验书P48页有写，这里解释一下：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">input [7:0] RL;</div><div class="line">...</div><div class="line">output KB;</div><div class="line">reg KB;</div></pre></td></tr></table></figure><p>RL对应键盘的「列」，从左到右，是第0列到第7列。</p><p>KB对应键盘的「行」，当KB为<code>0</code>时，键盘下面一行可用，即0-7.</p><p>当KB为<code>1</code>时，上面一行可用，即8-F.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	q = 1&apos;b0;</div><div class="line">    q = KB;</div><div class="line">    KB = ~q;</div><div class="line">end</div></pre></td></tr></table></figure><p>这段代码是为了以时钟频率反复扫描上下两行，所以时钟不要选太慢的，比如选8Hz就挺合适。</p><hr><p>RL[7]到RL[0]就是列输入，这些需要自行连线。比如从实验板上，将<code>KP_RL7</code>（在键盘上方）连了pin138，那引脚分配的时候，就将138分配给RL[7].请注意，书上的<code>input [7:0] RL</code>这个名字和实验板上的KP_RL0至KP_RL7类似，不要混淆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	case (&#123;KB,RL&#125;)</div><div class="line">        9&apos;b011111110:	//当按下「0」的时候要做的事</div><div class="line">        9&apos;b011111101:	//当按下「1」的时候要干的事</div><div class="line">        ...</div><div class="line">        9&apos;b111111110:	//当按下「8」的时候要干的事</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        default:		//什么按键也没按下</div><div class="line">    endcase</div><div class="line">end</div></pre></td></tr></table></figure><p>这里的<code>{}</code>是用来将两个数拼接在一起。</p><p>KB就表示行，KB为0的话就是下面一行有效。这些键盘是负有效，按下的时候变0，抬起的时候是1.</p><hr><p>实验板上的接线方式，这里给一个参考</p><p>从<code>KP_RL0</code>到<code>KP_RL7</code>，可连接pin166, 164 162 160 158 143 140 138。当然了，连哪个引脚都可以。</p><p><code>KP_RL0/7</code>旁边的<code>KP SL0</code>中，<code>KB1</code>和<code>KB2</code>接地，连接到实验板上任意写有<code>GND</code>的引脚即可。</p><p><code>KB0</code>需要连接到一个你自定义的引脚上（比如163），然后再引脚分配环节，将pin163分配给<code>KB</code>就可以了。</p><hr><p>如果你的电路设计，只需要用一行键盘，那就不需要写KB的0-1转换了。但是仍然要分配KB0，确保KB0恒为0（或恒为1即，用上边一行。）</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/11/23/cpp-keypoint/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/11/23/cpp-keypoint/" itemprop="url">C++考试重点解析 | 七系</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-23T13:06:11+08:00">2015-11-23</time></span></div></header><div class="post-body" itemprop="articleBody"><p>老师发来的考点是下面这些（原文）：</p><ol><li>类的静态成员和友元</li><li>数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</li><li>对象指针与动态内存分配</li><li>派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</li><li>虚基类</li><li>单目和双目运算符重载</li><li>多态程序编写，包括虚函数、纯虚函数以及抽象类</li></ol><p>这篇文章中我把这些知识点过一遍，正好我自己也复习一下…如果有错误还请指出，我进行勘误后再发一版。这篇文章不是一篇系统的知识点回顾，其中有很多我个人的理解，不甚准确，仅供有限的参考。另外，我的C++学的也比较一般，所以也希望能借此机会和大家多交流。</p><p>另外还请注意的是，咱们的课本写的还是挺清楚的，将这些知识点在书上找出来，再看几遍即可。</p><p>##1.类的静态成员和友元</p><p>###1.1关键字</p><ul><li>静态成员：static</li><li>友元：friend</li></ul><p>###1.2静态成员<br>定义：如果有一个成员，需要和他所属的<strong>类</strong>直接相关，而不是和由这个类生成的<strong>对象</strong>直接相关，此时需要静态成员。</p><p>举例：“北工大学生”作为一个类，可以派生出你，你，你，我，每一个人。而这个类中有一个成员变量“学生总数”，这个成员只和“北工大学生”这个类相关，而不和具体的某个学生对象相关。<br>比如说，“学生总数”这个<strong>成员</strong>，和“王大水”这个<strong>对象</strong>没有关系。</p><p>此时，如果修改任意一个对象中的静态成员，所有派生自同一个类的此静态成员都会同时被改变。也就是说，所有的由此类派生出的对象，都共享同一份静态成员，一变都变。</p><p>使用方法：在成员的声明前加上<code>static</code>。</p><p>比如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>此时，total前的<code>static</code>就是将此变量声明为静态成员的意思。</p><p>当然，<code>static</code>也可以加在<strong>成员函数</strong>的声明前。有什么用呢？比如说，你想在<strong>类还没实例化之前，就修改static变量的值</strong>，那这个修改用的函数也得是<code>static</code>的。</p><p>这块知识基本可以类比Java中学过的<code>Static</code>。</p><p>###1.3友元</p><p>友元的预备知识：访问的控制与封装，即<code>public</code>，<code>protected</code>，<code>private</code>关键字的功能。</p><p>可以这样不严谨但通俗地理解：</p><ul><li><code>public</code>：谁都能来使用我的东西，来者不拒</li><li><code>protected</code>：只有我的孩子孙子（继承自我的类）才能用我的东西</li><li><code>private</code>：只有我自己才能用我自己的东西</li></ul><p>友元的作用，是指定某一个函数(或某一个类的成员函数)“为自己的好朋友”，即可以使用自己的private内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span>;    <span class="comment">//const引用</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//输出信息用的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student stu1;</div><div class="line">    print (stu1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果print是一个用来输出学生对象中信息的函数，那这种方法(加friend)就相当于给了<code>print</code>函数一个特殊的权限。</p><p><code>friend</code>作用在<strong>类的成员函数</strong>时，用法也是一样的。</p><p>友元声明不写在<code>public</code>或<code>private</code>区域中。</p><p>总之，两个类之间需要共享数据的时候，可以使用友元。但请注意，友元实质上破坏了类的封装性。Java中就没有友元函数这一设定。</p><p>##2.数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</p><p>###2.1.数组作为函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * a)</span></span>;  <span class="comment">//声明方法1</span></div><div class="line"><span class="comment">//void sum(int [] a);   //声明方法2，这样也行</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">20</span>];  <span class="comment">//声明数组</span></div><div class="line">    sum (a);    <span class="comment">//传递这个数组为函数参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C语言里学过。形式大概就是上面这样。</p><p>###2.2指针作为函数参数，与地址相关的运算 <code>*</code> 和 <code>&amp;</code></p><p>C和C++语言中，同一个符号在不同的场合会有不同的意思。在和地址相关时：</p><ul><li><code>&amp;</code> ： 取址符</li><li><code>*</code> ： 取值符</li></ul><p>他们俩互为逆运算。<code>&amp;</code>就是取一个变量的地址（通常情况下，也就是指针的意思，但请不要认为地址==指针）。</p><p><code>*</code>的话就是“取一个地址内的值”，和上面的<code>&amp;</code>的操作正好相反。</p><p>就好比说，宿舍号“424”是一个地址，你取424的值，即<code>*424</code>，取出来的就是“王大水”这个值。如果你对“王大水”进行取址，即<code>&amp;王大水</code>，结果就是424.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> * p)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</div><div class="line">    <span class="keyword">int</span> * pointer1 = &amp;a;    <span class="comment">//将a的地址赋给指针pointer1</span></div><div class="line">    func(pointer1); <span class="comment">//指针作为函数参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> * p)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; p;      <span class="comment">//输出的是a的地址，即主函数中的&amp;a</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *p;     <span class="comment">//输出的是a的值，即233</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>##3.对象指针与动态内存分配</p><p>###3.1.对象指针</p><p>如果有一个指针<strong>指向了一个对象</strong>，那这个指针就是<strong>对象指针</strong>了。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student * pb = student1;   <span class="comment">//pb指向了对象student1，pb的类型是"BJUT_Student"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###3.2.动态内存分配</p><p>咱们在C语言里学过<code>malloc</code>，写法比较繁琐，一般是</p><figure class="highlight plain"><figcaption><span>* BJUT_Student</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在C++里大幅简化了这个功能（申请内存），约等于</div><div class="line"></div><div class="line">```BJUT_Student * student1 = new BJUT_Student();</div></pre></td></tr></table></figure><p>方便多了吧。</p><p>在C++里，尽量使用<code>new</code>，尽量不使用属于C语言的函数(例如<code>malloc</code>)。</p><p>##4.派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</p><p>###4.1.派生类的构造函数和析构函数</p><ul><li>构造函数：用来在新生成一个对象时初始化一些内容</li><li>析构函数：用来执行在销毁一个对象时要做的一些事情</li></ul><p>一般情况下，手写构造函数比较频繁，手写析构函数的机会不多。C++ Runtime 会自动为我们做一些事。</p><p>ps：构造函数在定义的时候，需要和<strong>类名相同</strong>。</p><p>派生类：即从已有的类继承而来的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A     <span class="comment">//基类A</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">int</span> x)&#123;</div><div class="line">        a = x;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    B(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : A(x)  <span class="comment">//派生类的构造函数，冒号后的是“初始化列表”</span></div><div class="line">    &#123;</div><div class="line">        b = y;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是这个意思，B继承自A。派生类的构造函数执行的时候，先执行父类的构造函数，也就是说<strong>初始化列表</strong>中的<code>: A(x)</code>.</p><p>析构函数也和类同名，但前面加了一个<code>~</code>，例如<code>~B(){//xxxxx}</code>。上述代码中没写析构函数。</p><p>派生类中的析构函数，执行的时候和构造函数的顺序相反，即先析构自己，再析构父类。<strong>除非</strong>父类的析构函数是虚函数(virtual)。</p><p>我还从来没实际用过析构函数，所以对这块不了解。一般情况下，对象销毁的时候，系统都自动为我们执行很多相当于析构函数的工作了。</p><p>关于“初始化列表”，可以简单的说：能用初始化列表的场合，都尽量使用初始化列表。尤其是，当某些const类型和引用类型的成员变量需要被初始化时，必须使用初始化列表，因为const或引用变量无法被复制（除初始化时）。</p><p>##4.2.复制构造函数</p><p>就我所知，一般在</p><ul><li>将对象作为参数传递，且为<strong>值传递</strong>的时候需要用到复制构造函数。</li><li>return一个对象。</li><li>纯粹复制一个对象。</li><li>构造一个对象时需要复制另外一个对象。</li></ul><p>说白了就是用来复制一个对象用的函数。关于值传递和地址传递的区别，可以参考我之前写过的文章。</p><p>复制构造函数的写法：一个<strong>参数为类的引用</strong>的构造函数，参数最好是const。例如：</p><p>复制构造函数在本质上还是构造函数，区别在于参数不同，用途不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B(<span class="keyword">const</span> B&amp;);    <span class="comment">//复制构造函数的声明</span></div><div class="line"></div><div class="line">B:B(<span class="keyword">const</span> B&amp; p)&#123; <span class="comment">//复制构造函数的定义</span></div><div class="line">    b = p.b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我的理解是：复制构造函数，就是一个明确指定“如何复制一个对象”的函数。</p><p>#4.3.派生类成员的标识与访问</p><p>不明白这是在说啥…</p><p>#5.虚基类</p><p>即在继承一个类的时候，在被继承的类名前面加个virtual。这在多继承时才会被用到。是为了消除二义性。</p><p>比如有基类A，B继承自A，C继承自A，又有D多继承自B和C。此时D中继承自A的成员，到底是哪一个A呢？（因为B和C分别复制了一份A的成员）这就产生了冲突。</p><p>如果在B和C继承A的时候，将A声明为<strong>虚基类</strong>即可解决这个问题，虚基类会确保A中的成员有且只有一份，D调用的时候就不会产生冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    A a;</div><div class="line">    B b;</div><div class="line">    C c;</div><div class="line"></div><div class="line">    a.i = <span class="number">1</span>;</div><div class="line">    a.print();</div><div class="line"></div><div class="line">    b.i = <span class="number">2</span>;</div><div class="line">    b.print();</div><div class="line"></div><div class="line">    c.i = <span class="number">3</span>;</div><div class="line">    c.print();</div><div class="line"></div><div class="line">    D d;</div><div class="line">    d.i = <span class="number">4</span>;    <span class="comment">//消除了二义性，如果不用虚继承，此处编译出错</span></div><div class="line">    d.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虚基类这事儿不常用。可以参考Java语言：根本就没有多继承，所以也不用操心这些事儿。</p><p>注：在Java中，和「多继承」类似的功能一般靠接口(interface)实现。</p><p>##6.单目和双目运算符重载</p><p>运算符重载是C++的一个特点，另一门面相对象语言即Java中，就没有运算符重载。因为他们的设计哲学有区别吧。</p><p>之前咱们学过函数的重载，即，当函数名相同，但函数参数列表不同时，程序会根据咱们实际所给的参数列表，动态地选择应调用的函数。</p><p>运算符重载也差不多，经过重载，同样地运算符在参与不同的数据类型（比如：int，double 就是两种不同的数据类型），会有不同的表现。</p><p>这是双目运算符的重载：(课本P310)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">Complex::<span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> Complex(<span class="keyword">this</span>.real + c2.real, <span class="keyword">this</span>.imag + c2.imag);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在双目运算符的重载中，运算符左边的操作数就是this。this一般可以省略。右操作数作为参数传递进来，也就是说这里的c2.</p><p>为什么需要重载这个加号呢？因为<code>Complex</code>类型是用户自定义的类型，C++编译器不知道该如何将两个这样的对象“加”在一起，需要用户手动描述。</p><p>单目运算符的重载也是一个意思。比较常用的单目运算符重载是<code>++</code>,<code>--</code>，值得注意的是，单目运算符重载一般没有参数（被运算的数作为this指针隐式传递）。</p><p>还有一种情况，即用友元函数进行运算符重载，这样的话，双目运算符重载就有两个参数，单目运算符重载就有一个参数。因为友元函数运算符重载没有this指针。</p><p>关于自增运算符前置、后置的重载，可以参考课本P312，非常清楚。</p><p>##7.多态程序编写，包括虚函数、纯虚函数以及抽象类</p><p>###7.1.多态，虚函数</p><p>什么是多态呢…</p><p>书上的定义不太好理解，一般都是类似于“对同一个消息作用在不同的对象上，会产生不同的效果”。你可能会问，这不是废话吗？比如有个父类Animal，子类Dog，我让Animal“吃”，和让Dog“吃”，效果肯定不一样啊，这还用系统给我判断？</p><p>你说的没什么错。按照我的理解，什么时候需要多态性呢？</p><p>比如有个<code>Animal</code>类型的指针<code>a</code>，这个指针<code>a</code>指向<code>Animal</code>的时候，你调用<code>a.eat()</code>。指针再指向<code>Dog</code>的时候，你又调用<code>a.eat()</code>。此时如果能分别正确调用<code>Animal</code>和<code>Dog</code>的<code>eat()</code>方法，那这就是多态。</p><p>如果你分别用指向<code>Animal</code>和指向<code>Dog</code>的指针，分别调用<code>eat()</code>，这就不叫多态。</p><p>多态这件事和<strong>继承</strong>是<strong>紧密相连</strong>的。</p><p>咱们应该是都学过Java了，为啥Java中没怎么提到过多态呢？确实如此，因为Java中的类的继承，在默认的情况下就已经实现了多态了。</p><p>但C++就没这么自动化，如果想让一个父类的某个成员函数能实现多态性，就必须规定这个函数为<code>虚函数</code>。</p><p>用刚才那个例子来说，也就是说得让Animal类中的eat()方法前加上一个virtual。类似：</p><figure class="highlight plain"><figcaption><span>void eat()&#123;//xxx&#125;;```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###7.2.纯虚函数</div><div class="line"></div><div class="line">纯虚函数是一种特殊的虚函数。即只声明，不实现定义。由继承下去的子类去具体实现。</div><div class="line"></div><div class="line">写法是这样：</div><div class="line"></div><div class="line">```virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</div></pre></td></tr></table></figure><p>加了一个<code>=0</code>。注意,<code>virtual</code>也不能少。</p><p>我个人理解：纯虚函数对应Java中的抽象(Abstract)函数。</p><p>###7.3.抽象类</p><p>只要是包含了纯虚函数的类就自动被归为抽象类。和Java中的抽象类类似，不能被实例化为对象，只能被继承。</p><p>抽象类中至少存在一个纯虚函数；存在纯虚函数的类一定是抽象类。存在纯虚函数是成为抽象类的充要条件。</p><h2 id="完毕。"><a href="#完毕。" class="headerlink" title="完毕。"></a>完毕。</h2><p>C++的确很有用，非常强大，效率很高。坦诚地讲，也很有学习的必要。但从我个人的角度，以及我目前对C++及其浅薄的认识，我不是很喜欢C++这门语言给我的感觉。强类型的面向对象语言中，我更喜欢Java。目前我正在(以极其缓慢、肉眼几乎难以辨别的速度)学习Python，如果有同感兴趣的朋友请一起来交流。</p><p>当然了，我想强调的是，我承认C++作为<strong>基石</strong>的作用。我也同意，作为计算机专业的学生，有必要对C++进行相对深度的学习。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/10/27/DC-regulated-power/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/10/27/DC-regulated-power/" itemprop="url">直流稳压电源(电路实验1)笔记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-27T17:38:05+08:00">2015-10-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>电子实验的第一个实验，「直流稳压电源」。由于实验小册子上的图和文字实在是太抽象、太魔性了，我把我对这个电路的一些认识写在这里，供参考。如果写错了内容并对你的电路(和心理)造成了不可逆转的伤害，我请你吃冰棍。</p><p>另外，我的器件包里没有任何<strong>电阻</strong>，但 @辛德龙 就有俩氪金彩色电阻，大家都有电阻吗？</p><p>#认识元器件</p><p>元件和器件是有区别的。在我看来，电阻、电容这类比较基础的东西就是「元件」，差分放大器、集成电路的话就算「器件」</p><p>##电解电容（大）<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/82966437.jpg" alt=""></p><p>1000μF</p><p>和整流桥并联。</p><p>给转换出的直流电做滤波(?)和稳压(?)用的，总之是个缓冲作用。这个电路上大多数的电容都是缓冲作用。</p><p><strong>听说这个电容接反的话会爆炸。</strong>，有白条的一侧就是负极。同时，引脚长的一侧为正极。</p><p>这个黑色电解电容，从包装来看是Rubycon牌子的，我上网查了一下，怀疑是假货。</p><p>##电解电容（小）</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/62548616.jpg" alt=""></p><p>数量若干。</p><p>##陶瓷电容</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26675224.jpg" alt=""></p><p>这种电容不用分正负。听说也不会爆炸？</p><p>##整流桥</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/24418714.jpg" alt=""></p><p>能将交流电转为（<em>不那么平整的</em>）直流电。大约是1V交流电（有效值）能转为1.2V直流电。</p><p>看印刷，<strong>两个「~」接交流电，「+」和「-」就是直流输出</strong>。</p><p>其实就是小册子上的这玩意：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/46572702.jpg" alt=""></p><p>因为这个整流桥的内部就是封装了4个二极管。</p><p>##二极管</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/73668153.jpg" alt=""></p><p>型号：1N4007</p><p><strong>有白环的一侧为负极</strong>。在咱们这个电路中，接在7805的1，3引脚之间，保护用。引脚3接二极管正极。</p><p>##稳压器</p><p>型号可能是「LM7805」</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/16602044.jpg" alt=""></p><p>从印刷字的一侧看，<strong>左起为引脚1，2，3</strong>。1接正极，3接输出，2接地。</p><p>由于经过整流桥整流过的直流电，还不是很平整（参考上面整流桥的波形图），这个7805就是撸平电流用的，作用类似电熨斗。</p><p>这个7805稳压器能稳定输出5V直流电源，输入的话一般在7-10V。那这几V的电去哪了？被这个器件变成热量了。上面的那个孔，就是接散热片用的。不过咱们这个电路电流不大，我估计不需要散热片。</p><p>##功率放大器</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26540379.jpg" alt=""></p><blockquote><p>图：百度图片</p></blockquote><p>其实已经不是「直流稳压」部分的功能了。估计是为了驱动喇叭。</p><p>咱们给的是「386D」，和「LM386」的原理基本一样，应该是生产的厂商不一样。</p><p>有圆形凹陷的那个角，是引脚1（所有器件都这样）。引脚图：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/76078863.jpg" alt=""></p><blockquote><p>图：JRC的器件手册</p></blockquote><ul><li>引脚1，8：接一个电容，调节用</li><li>引脚2：反相输入（信号源）</li><li>引脚3：正相输入（信号源）</li><li>引脚4：接地</li><li>引脚5：输出信号</li><li>引脚6：电源（在咱们这个实验中就是7805给的5V直流）</li><li>引脚7：旁路（接一个电容，电容再接地。好像是对输出信号的稳定有好处）（去耦?）</li></ul><p>反相和正相输入，大概就是咱们电路课正在学的功率放大器吧。</p><p>##管脚座(?)</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/30867599.jpg" alt=""></p><p>386一定要插在管脚座上，将管脚座焊接在电路板上。我不确定是不是叫「管脚座」这个名字。</p><p>建议7805也接在座上，毕竟听说<em>电烙铁可能会焊坏器件（给的热量太多）</em></p><p>#电路图</p><p>小册子上的图太魔性了简直。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/43741313.jpg" alt=""></p><p>感谢 @曾檬 @孙昀淏 分享图片，拯救我于水火之中。此图建议大家存好，你懂得。</p><p>#总之<br>想搞一个8Ω小喇叭，没搞来。</p><p>焊锡就给那么点，器件焊坏了还不给分，这真的是实验课？这让人怎么练手？非得让人缩手缩脚？一个器件有几块钱？我出钱买还不行吗？焊坏一个器件就不给分？</p><p>##接地是啥意思？</p><p>我理解接地，就是接「低电平」的意思，在咱们这个电路中，唯一可行的低电平就是电源负极。也就是说接地就是接电源负极的意思。</p><p>没必要接大地。</p><p>##一些笔记</p><ul><li>防止输入对地短路</li><li>防止输入输出接反</li><li>防止输入滤波电路短路（大概会爆炸？）</li><li>防止输出与高电平接（大概会烧坏器件）</li><li>防止三 - 地 - 开路 （原文如此，我也忘了记的是啥意思了，求解）</li></ul><p>##总之</p><p>这个电路：</p><ol><li>将交流电，用整流桥（扁平圆柱，四脚），变成不平整的直流电</li><li>将不平整的直流电，用稳压器（7805，三脚），变成平滑的5V直流电</li><li>用5V的直流电驱动功放（386D，八脚）</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/09/26/programming-language/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/26/programming-language/" itemprop="url">都有啥编程语言？</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-26T20:05:26+08:00">2015-09-26</time></span></div></header><div class="post-body" itemprop="articleBody"><p>编程的语言多种多样，那么编程语言都有哪些呢？</p><p>本期栏目会根据2015年9月TIOBE的排行榜，对当下排名前20的编程语言做一个<em>非常简单</em>的阅览，以后再展开细说。对编程语言的介绍，由于王大水同学孤陋寡闻，难免存在错误，还请大家指出。</p><blockquote><p>TIOBE是一个编程语言的流行度排行榜，每月出一期。这个排行榜只能在一定程度上反映编程语言的流行程度，并不代表某种编程语言更好，没必要过度解读。</p></blockquote><p>#2015年9月排行<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-26/21170782.jpg" alt=""></p><p>其实也就前十左右还算是「主流」的编程语言。</p><p>#Java</p><p>Java语言很牛。近十多年来，Java基本上一直雄踞TIOBE榜首。</p><p>Java语言在刚面世的时候（1995年）心气非常大。Java想统一所有的平台，设计者的意思是，「有Java就足够了，其他编程语言都是渣渣」。虽然如今Java并没有这么万能，不过也是很厉害了。Java在企业后台开发、网页后端、Andriod开发、云计算、大数据等领域需求都很大。</p><p>Java是非常成熟的面向对象语言，Java宣称「Java语言中的一切都是”对象”」（虽然并不真正如此）。相比C++语言来说，Java是一个更加纯粹的面向对象语言。Java舍弃了很多『危险』的设计，比如指针、比如不让程序员手动操作内存。Java语言的安全性非常不错（相比C++和C），但在效率上就有所牺牲。</p><p>学Java的过程，相比学习C语言，是<em>非常</em>幸福的事情。</p><p>咱们计算机系的话，一般都是会学Java的。我的个人建议是，体会面向对象的初步思想，这是关键。要明白「继承」、「对象」、「类」这些概念的准确意思。因为任何面向对象语言中，这些东西都是想通的。至于Java语言的语法细节，或者Java的图形库等等细节的东西，不用抠太细了。</p><p>啰嗦一下，<strong>最好别用学文科的方法学编程。</strong></p><blockquote><p>名词解释</p><ul><li>Java SE。就是咱们平时学Java时所用的Java库的版本。如果大家有玩过「Minecraft」的话，应该还记得在运行MC之前必需安装Java，因为MC就是用Java编写的。你问为何Windows操作系统不自带Java？哈，他们两家公司的恩怨情仇回头还能细说。</li><li>Java EE。企业开发用的Java，不懂。</li><li>Java ME。M是Micro的意思，一般在单片机版之类的地方用，似乎已经没什么人在用了。</li></ul></blockquote><p>#C</p><p>就是咱们正在学的C语言。这算是老前辈了（1972）年，因为C既有「<em>高级</em>程序设计语言」的特点，又能操纵硬件层面的细节，所以很受程序员欢迎。</p><p>但是C语言是面向过程的语言，而且C语言中的「指针」「手动内存管理」等特性容易造成BUG，所以如今C语言用的已经不是太多了。但是毕竟是有用的，比如Linux(一种操作系统)大多数的代码由C语言构成。写单片机、数值计算领域，C语言还是用的很广泛的。</p><p>#C++<br>也是老牌面向对象语言了。我想出过一个比喻，我觉得用来形容C++语言还是挺恰当的。</p><p>「C++语言是一艘航空母舰，攻击力强大。但烧煤的发动机拖累了它。」</p><p>啥意思呢？C++语言在设计的时候，为了兼容C语言，便设计为「C语言的超集」，也就是说C++完全向下兼容C语言（从这门语言的名字也能看出来这一点）。这样一来，C++就背上了沉重的历史包袱。</p><p>比如为什么咱们能在「Visual C++」这个软件中编写C语言呢？就是这个意思。</p><p>#C井</p><p>「C#」，<strong>读做「C sharp」</strong>。就是「C 升号」的意思。（变相表达C”++“）</p><p>我猜测，如果读「C井」的话，只要读满65535次，有一定几率下辈子投胎M78星云。</p><p>C#是微软公司出品的一款编程语言，其实就是模仿Java整出来的一款竞品。C#我没接触过，听说很好用，很好学，很强大。很多桌面程序都是用C#写的。</p><p>说白了，你要是Java学得好，C#分分钟就会了。</p><p>#Python</p><p>Python可火了，啥都能干。Python语言相对优雅，相对速度还不错，相对易于学习。很多国外的大学，计算机专业的入门语言便是Python。听说国内有少数大学也在尝试用Python作为第一门编程语言。</p><p>数值计算、网站后端、脚本、还有今天特别火的大数据、机器学习啥的，Python好像都有份。</p><p>Python语言的特点之一是强制要求你使用规范的代码缩进。</p><p>#PHP</p><blockquote><p>「PHP」是世界上最好的编程语言。——PHP程序员</p></blockquote><p>PHP主要是在CGI（即网站后端）用途广泛，是一门非常经典的服务器后端语言。语法和C比较接近。</p><p>#JavaScript</p><blockquote><p>「Java」和「JavaScript」的关系，就如同雷锋和雷峰塔的关系。——知乎用户</p></blockquote><p>JavaScript的名字中为啥有个Java呢？可以这样简单理解：JavaScript的设计者抱Sun公司（开发Java的公司）大腿。</p><p>Javascript如今也是越来越火了，有前后端通吃的气势。</p><p>由于当初设计Javascript的人是个「Lisp」语言脑残粉，所以Javascript中的面向对象特性特别难用。但是毕竟人家已经成为了连接网站前后端的唯一语言了，几乎没有竞争对手。所以值得接触一下。</p><p>#Visual Basic .NET<br>名词解释</p><ul><li>Visual Basic，即VB。似乎很多人之前就接触过，就是拖一个个控件，然后就能做出个还算好看的程序。</li><li>.NET，我的理解是：微软的一整套东西，合在一起叫.NET。</li></ul><p>我觉得「Visual Basic .NET」就是咱们平时说的VB。</p><p>倒是一门不错的教学语言。我之前还真用Excel中的VB写了一个「生命游戏」，有兴趣请看我Github。</p><p>#Perl</p><p>没用过，似乎是一种处理字符串非常强大的语言。比如说，Perl内置了「正则表达式」，而正则表达式用来处理字符非常厉害。</p><p>似乎Perl和Linux/Unix结合使用的情况比较多。</p><p>这也是一门有年头的语言了，大概是20世纪80年代推出的。</p><p>#Objective-C</p><p>其实也挺老了，本来都快要退出历史舞台了，但正好Apple公司选了了Obj-C语言作为平台开发语言，所以又火了。</p><p>不过今天Apple公司也使用新的Swift语言了。不知道Objective-C何去何从。</p><p>#Assembly language</p><p>就是「汇编语言」的意思。</p><p>汇编语言是一种介于「机器语言」（01二进制代码）和「高级语言」（比如C语言）之间的一种语言。</p><p>恩…不知道什么人还在用。也许是写底层程序和驱动的吧。</p><p>#Ruby</p><p>如果说Ruby语言没有汇编语言流行，打死我也是不会信的。所以说这个排行榜看看就好。</p><p>Ruby是源自日本的一种编程语言，在网站开发方面非常流行。Github这个社区，最早就是Ruby程序员爱好者建立起来的。</p><p>#Delphi</p><p>听说这门语言在数据库方面用的比较多，「Dev-C++」这款软件也是用Delphi写的。</p><p>不过据我所知，Delphi已经基本退出历史舞台了。Delphi的前身是Pascal。</p><p>#Visual Basic</p><p>不知道这和Visual Basic .NET有啥区别。</p><p>#Pascal<br>想当年这也是挺火的语言。</p><p>我初中的时候，比如NOIP竞赛，Pascal和C语言还是并列的关系。他们都是经典的面向过程的语言。在我的指导老师上学的时候，Pascal是必修课，C语言是选修课。可见Pascal昔日的辉煌。</p><p>这门语言的名字是为了纪念数学家「帕斯卡」。帕斯卡发明了「加法器」，可谓是人类历史上的第一个「计算机器」。</p><p>也已经退出历史舞台了。</p><p>#Swift</p><p>Swift就是现在Apple公司力推的开发语言。Apple Store里的那些App，如今应该有好多已经是Swift写的了。</p><p>#MATLAB</p><p>一种主要用于数值计算的软件。但Matlab能干的事儿远不止数值计算，比如算法开发、数据可视化、数据分析、建模仿真等等，都能干。</p><p>更纯粹的数值计算软件是「Mathematica」，还有个同类的软件叫「Maple」。</p><p>#PL/SQL</p><p>PL/SQL是「过程化SQL」的意思，是「Oracle」（即甲骨文）公司独有的。如今Java语言的版权便归属于Oracle。</p><p>SQL是「结构化查询语言」的意思，在数据库中有非常广泛的应用。</p><p>#R</p><p>是一种统计领域中使用较多的语言。比如学经济/金融的同学，或者搞数学建模的同学，大概会接触到R语言吧。</p><p>#COBOL</p><p>这是一个20世纪60年代就有的语言。在企业/银行的数据管理中运用广泛。</p><p>#小结</p><p>有一种说法：一个好的计算机专业毕业生，应该掌握</p><ul><li>一门面向过程的语言</li><li>一门面向对象语言</li><li>一门脚本语言</li></ul><p>如果学有余力，最好</p><ul><li>对函数式语言有所了解</li></ul><p>打个比方，如果我毕业的时候熟悉C、Java和Python，对Scala有一定了解，就算是符合这个条件了。</p><hr><p>这个榜单一直排了50种编程语言。后边的语言，有些是应用的领域非常小，有些则是历史遗留产物了。</p><p>值得一提的是，排名第48的编程语言是「VHDL」，眼熟吗？</p><p>谢谢@刘鑫学长的提醒，数字逻辑这门课要学的是 Verilog HDL，和VHDL还是有些区别。不过他们能干的事儿都差不多。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/09/24/too-many-authentication-failures-error/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/24/too-many-authentication-failures-error/" itemprop="url">ssh 连接时出现 too many authentication failures error</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-24T19:09:12+08:00">2015-09-24</time></span></div></header><div class="post-body" itemprop="articleBody"><p>我在mac上，尝试用ssh连接我的ubuntu主机，但报错：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Received disconnect from x.x.x.x: Too many authentication failures for username</div></pre></td></tr></table></figure><p></p><p>我在<a href="http://theandystratton.com/2012/ssh-returns-too-many-authentication-failures-error-hostgator" target="_blank" rel="noopener">这个</a>网址找到了一个解决方案：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -o PubkeyAuthentication=no username@x.x.x.x</div></pre></td></tr></table></figure><p></p><p>就可以正常输入密码并登陆了。</p><p>似乎是<code>~/.ssh</code>中的密钥太多了，如果把这些密钥删除也能解决问题。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wangyufeng.org/2015/09/18/c-learning-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Alan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="王雨峰的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/18/c-learning-1/" itemprop="url">C语言学习札记(一)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-18T17:45:10+08:00">2015-09-18</time></span></div></header><div class="post-body" itemprop="articleBody"><p>本期写一些初学者学C语言时可能会遇到的问题，为什么说是「可能遇到」呢？因为这些基本上都是我在学习的过程中遇到过的问题，曾经困扰过我。文章内容都是基础的内容，如果你觉得阅读起来有困难，可能是因为你还没学到那里。别着急，可以先收藏这篇文章，学习的过程中，想到这个问题时可再回来看看。</p><p>想到啥写啥。没时间列大纲了。</p><p>分享给各位学弟学妹一个建议：<strong>请以审辩的态度去听取他人的建议，包括我的这条建议。</strong>为什么呢？因为大家所走的路，和你将要走的路，尤其是你 <em>想</em> 要走的路，很可能相差甚远。别人的建议可能对你来说没有价值，甚至对你有负面的价值。比如说，会有人说「C语言的细节很多，不用搞明白那些细节」，也有人说「C语言不重要，你直接看面向对象语言就行」。这些意见自然多多益善，但对你最了解的还是你自己。</p><p>哈，上边出现了一个递归，你发现了吗？递归是咱们计算机科学中非常有意思的一件事，大家在学「函数」这章的时候，递归也是个不太容易理解的地方。不过大家可以放心，在C语言中，递归的方案完全可以转化为循环(while/for/do,for)的方案，除非在特殊的情况下，使用递归的场合不多。</p><p>一周下来四晚有课，心堵。</p><p>#如何向他人求助程序问题？</p><p>##搜索引擎是你最好的帮手</p><p>你所遇到的任何问题，有99.99%的几率，已经被别人遇到过了。在互联网上，有很多人在提问，也有很多热心的人在解答。将你的问题非口语化的描述，或报出的错误信息放在搜索引擎上查一查，一般问题都能得以解决。像是百度知道 / csdn和博客园的博客 / 知乎 之类的网站，存在着很多问题的解决方案。</p><p>如果总是查不到，可能是选取的关键词、或错误信息的提取不够准确。多查查就有感觉了。</p><p>##善用错误信息</p><p>如果程序存在语法问题，那么在编译的时候，VS会给你报个错。这些Error都是有描述性的信息的，大多数情况下，根据这些信息便可以修正程序错误。但往往错误信息是<em>英文的</em>，但都不复杂，很容易读懂。大不了把错误信息在百度上搜一下。</p><blockquote><p>Tips，如果错误信息在百度上查一无所获，去Google上试一试，往往有惊喜。</p></blockquote><p>但有些情况下，VS给你的错误信息让你觉得莫名其妙，完全驴唇不对马嘴。这种情况也是常见的，毕竟VS不是万能的。这种情况下，请参见下一个建议：</p><p>##再多读一遍<br>真的，这招太有用了。</p><ul><li>main → mian</li><li>true → ture</li><li>就算我按不序顺话说你能看也懂</li></ul><p>这种错误很容易犯，我现在写程序手一抖就打出个ture，然后还一点都看不出来。其实C语言还好，像是Javascript（大家以后可能会接触到）这样的『不那么严格的语言』，如果打错变量名，想找出错误来能把人累死。很多奇怪的问题都是由于细节的错误造成的，比如打错了字、少打了右大括号，打了不该打的分号，等等。如果问题就是特别奇怪，特别顽固，请试着再读一遍程序。</p><p>当然了，编译器能报错这件事，就已经令人感到非常幸福了。将来大家都会写大课设，到时候就会发现，绝大多数错误都是编译器报不出来的。尤其是一些「确实已经写错了的地方，但是C语言编译器以为你想故意这样hack一下」的错误，就不得不需要调试的手段了。现在大家除了F10逐行运行之外，还不需要太多调试的方法，但养成好的写代码习惯，比如命名、代码格式等等，还是请从现在做起。</p><p>#为什么能写C语言的程序有那么多？<br>你可能会发现，大家用于学习C语言的软件都不太一样。在机房，老师可能为大家展示VC6.0；你的同学中，有些人用Code::Blocks，有些人用着迷离的高端程序，你可能正在用VS2015.</p><p>它们有什么区别？区别不大。它们都被称作「IDE」，都能写C语言。只是各种附加的工具不同。想详细了解「IDE」，可翻阅本公众号的往期文章。</p><p>请注意：C语言不是程序，C语言只是一种『编程语言』。所以说用哪种「IDE」去学习，都是无关紧要的。我个人推荐大家使用VS。</p><blockquote><p>其实VS和其他的IDE还是有些区别，这些区别有时能能影响到大家。有时候，可能你同学写好的、能够完美运行的代码，完整复制到你的电脑上，却运行不正常，甚至没法编译。因为VS的「编译器」和其他的IDE多少有些不一样。甚至VS和VC也不一样。「编译器」决定了IDE如何去处理代码，而不同的编译器的处理方法有所不同。那应该怎么办？尽量使你的代码写的规范，就能大大避免这种问题。下面有相关的问题会提到。</p></blockquote><p>#注意 = 和 ==<br>在C语言中，</p><ul><li>= 叫做 赋值号</li><li>== 叫做 等于判断符</li></ul><p>这事儿是个大坑，基本每个人都得栽里边儿，我就栽在里面很多很多次。</p><p>比如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (a = 1)</div></pre></td></tr></table></figure><p></p><p>这种语句，你的意思可能是如果a等于1，就怎么样。但在这里，会把 1 赋值给 a。关键在于，这种问题程序是不报错的。那为什么程序不报错呢？因为(a = 1)理论上可作为一个表达式，这个表达式也是可以表达值的。</p><p>听说有些编译器会对这种情况报一个 Warning，因为这种错误实在是太常见了，专业的程序员也有时中招。</p><blockquote><p>理论上的建议是，不将『左值』作为变量名，也就是说只写(1 == a)而不是(a == 1)，因为这样的话就算是不小心少打了一个=，编译器就会报错。因为常数1不能被赋值。</p></blockquote><p>#到底是 void main 还是 int main ?<br>大家已经学习到了，C语言中最核心的函数是「主函数」，主函数就是形如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">	xxxxxx....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这样的函数。大家可能会注意到，在有些课件和书上的示例中，写的是<code>void main</code>，那到底哪个对？</p><p>先给结论：<strong>只写</strong><code>int main</code></p><p>int main 是目前最为规范的写法。C语言自诞生以来，并不是一成不变的。有些特性被淘汰、有些被更新、还有些新的特性加入，所以可以这样理解，void main 是一种历史遗留的写法，已经不用了。那为什么书上和课件上还有呢？大家可以注意观察下，有些课件的年龄已经10+了。或者说，咱们的老师学这门语言的时候，规范和今天并不一样。</p><p>#主函数最后的 return 0 是什么意思？<br>其实这个<code>return 0</code>是可以不写的。如果不写的话，相当于「编译器」自动帮我们加上这行。return 0如果写的话，必须写在主函数的最后一行写。如果return 0后边还有语句，就不会被执行。</p><p>大家观察<code>int main(){}</code>最前面的<code>int</code>。可能大家还没有学到「函数」，这里为大家介绍一下，C语言中的「函数」(function)和数学里的函数可以类比理解，即「给这个函数参数」，然后「函数返回给你结果」。所以在C语言中，函数名前面的「类型」就指的是「函数返回值的类型」。</p><ul><li>int add(1,2){ … } ， 表示 add 这个函数的返回值的类型是整型(整数)</li><li>void run(){ … } , 表示 run 这个函数没有返回值(void 差不多是「nothing」的意思)</li></ul><p>那么，int main 的意思就是，<strong>主函数的返回值类型是整型</strong>。</p><p>你也许会问，既然C语言中函数的返回值是给用户看的，那为什么主函数也有一个「返回值」呢？答案是这样的：对于普通的函数来说，调用他们的人是「主函数」，也就是说他们的返回值会返回给「主函数」。那么主函数是谁调用呢？是「操作系统」调用主函数。比如你的电脑是Windows 7，那么就是Windows 7 调用了这个主函数。</p><p>那为什么需要返回值？当一个主函数返回一个「0」给操作系统时，操作系统就知道这个函数的运行结果「正常的」，也就是这个函数正常地运行完毕了。这就是 return 0 的意义。</p><hr><p>今天就发这几个吧。如果大家有任何问题，欢迎后台来留言或直接跟我聊。我保证，如果我不知道答案、也在网上查不到资料的话，我会说不知道，保证不跟你胡诌。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Alan</p><p class="site-description motion-element" itemprop="description">Alan Wang's personal blog.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></div></nav></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Alan</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html>