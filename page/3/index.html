<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//fonts.gmirror.org/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//cdn.bootcss.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css"><meta name="keywords" content="王雨峰, 博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2"><meta name="description" content="Alan Wang&apos;s personal blog."><meta property="og:type" content="website"><meta property="og:title" content="王雨峰的博客"><meta property="og:url" content="http://wangyufeng.org/page/3/index.html"><meta property="og:site_name" content="王雨峰的博客"><meta property="og:description" content="Alan Wang&apos;s personal blog."><meta name="twitter:card" content="summary"><meta name="twitter:title" content="王雨峰的博客"><meta name="twitter:description" content="Alan Wang&apos;s personal blog."><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"}}</script><link rel="canonical" href="http://wangyufeng.org/page/3/"><title>王雨峰的博客</title></head><body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-76286580-1","auto"),ga("send","pageview")</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="//schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">王雨峰的博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">随便写点东西，为互联网贡献一些比特。</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于我</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">文章归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/12/01/shu-zi-luo-ji-shi-yan-tips-1/" itemprop="url">数字逻辑实验，如何使用键盘</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-12-01T18:43:56+08:00" content="2015-12-01">2015-12-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>开关（SW1-SW16）自然也可以作为输入，但有些情况更适合用键盘输入，比如密码锁，模拟投币等。</p><p>键盘就是试验箱右下角，0-F的圆形按钮。</p><p>在做这次实验之前，我原以为键盘的输入方式和开关类似，即按下为1，松开为0，但实际上不是这样。如果想使用键盘，还需要专门写一段「键盘扫描程序」。</p><p>程序在实验书P48页有写，这里解释一下：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">input [7:0] RL;</div><div class="line">...</div><div class="line">output KB;</div><div class="line">reg KB;</div></pre></td></tr></table></figure><p>RL对应键盘的「列」，从左到右，是第0列到第7列。</p><p>KB对应键盘的「行」，当KB为<code>0</code>时，键盘下面一行可用，即0-7.</p><p>当KB为<code>1</code>时，上面一行可用，即8-F.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	q = 1&apos;b0;</div><div class="line">    q = KB;</div><div class="line">    KB = ~q;</div><div class="line">end</div></pre></td></tr></table></figure><p>这段代码是为了以时钟频率反复扫描上下两行，所以时钟不要选太慢的，比如选8Hz就挺合适。</p><hr><p>RL[7]到RL[0]就是列输入，这些需要自行连线。比如从实验板上，将<code>KP_RL7</code>（在键盘上方）连了pin138，那引脚分配的时候，就将138分配给RL[7].请注意，书上的<code>input [7:0] RL</code>这个名字和实验板上的KP_RL0至KP_RL7类似，不要混淆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">always @ (posedge clk) begin</div><div class="line">	case (&#123;KB,RL&#125;)</div><div class="line">        9&apos;b011111110:	//当按下「0」的时候要做的事</div><div class="line">        9&apos;b011111101:	//当按下「1」的时候要干的事</div><div class="line">        ...</div><div class="line">        9&apos;b111111110:	//当按下「8」的时候要干的事</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        default:		//什么按键也没按下</div><div class="line">    endcase</div><div class="line">end</div></pre></td></tr></table></figure><p>这里的<code>{}</code>是用来将两个数拼接在一起。</p><p>KB就表示行，KB为0的话就是下面一行有效。这些键盘是负有效，按下的时候变0，抬起的时候是1.</p><hr><p>实验板上的接线方式，这里给一个参考</p><p>从<code>KP_RL0</code>到<code>KP_RL7</code>，可连接pin166, 164 162 160 158 143 140 138。当然了，连哪个引脚都可以。</p><p><code>KP_RL0/7</code>旁边的<code>KP SL0</code>中，<code>KB1</code>和<code>KB2</code>接地，连接到实验板上任意写有<code>GND</code>的引脚即可。</p><p><code>KB0</code>需要连接到一个你自定义的引脚上（比如163），然后再引脚分配环节，将pin163分配给<code>KB</code>就可以了。</p><hr><p>如果你的电路设计，只需要用一行键盘，那就不需要写KB的0-1转换了。但是仍然要分配KB0，确保KB0恒为0（或恒为1即，用上边一行。）</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/11/23/cpp-keypoint/" itemprop="url">C++考试重点解析 | 七系</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-11-23T13:06:11+08:00" content="2015-11-23">2015-11-23</time></span></div></header><div class="post-body" itemprop="articleBody"><p>老师发来的考点是下面这些（原文）：</p><ol><li>类的静态成员和友元</li><li>数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</li><li>对象指针与动态内存分配</li><li>派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</li><li>虚基类</li><li>单目和双目运算符重载</li><li>多态程序编写，包括虚函数、纯虚函数以及抽象类</li></ol><p>这篇文章中我把这些知识点过一遍，正好我自己也复习一下…如果有错误还请指出，我进行勘误后再发一版。这篇文章不是一篇系统的知识点回顾，其中有很多我个人的理解，不甚准确，仅供有限的参考。另外，我的C++学的也比较一般，所以也希望能借此机会和大家多交流。</p><p>另外还请注意的是，咱们的课本写的还是挺清楚的，将这些知识点在书上找出来，再看几遍即可。</p><p>##1.类的静态成员和友元</p><p>###1.1关键字</p><ul><li>静态成员：static</li><li>友元：friend</li></ul><p>###1.2静态成员<br>定义：如果有一个成员，需要和他所属的<strong>类</strong>直接相关，而不是和由这个类生成的<strong>对象</strong>直接相关，此时需要静态成员。</p><p>举例：“北工大学生”作为一个类，可以派生出你，你，你，我，每一个人。而这个类中有一个成员变量“学生总数”，这个成员只和“北工大学生”这个类相关，而不和具体的某个学生对象相关。<br>比如说，“学生总数”这个<strong>成员</strong>，和“王大水”这个<strong>对象</strong>没有关系。</p><p>此时，如果修改任意一个对象中的静态成员，所有派生自同一个类的此静态成员都会同时被改变。也就是说，所有的由此类派生出的对象，都共享同一份静态成员，一变都变。</p><p>使用方法：在成员的声明前加上<code>static</code>。</p><p>比如：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>此时，total前的<code>static</code>就是将此变量声明为静态成员的意思。</p><p>当然，<code>static</code>也可以加在<strong>成员函数</strong>的声明前。有什么用呢？比如说，你想在<strong>类还没实例化之前，就修改static变量的值</strong>，那这个修改用的函数也得是<code>static</code>的。</p><p>这块知识基本可以类比Java中学过的<code>Static</code>。</p><p>###1.3友元</p><p>友元的预备知识：访问的控制与封装，即<code>public</code>，<code>protected</code>，<code>private</code>关键字的功能。</p><p>可以这样不严谨但通俗地理解：</p><ul><li><code>public</code>：谁都能来使用我的东西，来者不拒</li><li><code>protected</code>：只有我的孩子孙子（继承自我的类）才能用我的东西</li><li><code>private</code>：只有我自己才能用我自己的东西</li></ul><p>友元的作用，是指定某一个函数(或某一个类的成员函数)“为自己的好朋友”，即可以使用自己的private内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BJUT_Student&#123;</div><div class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span>;    <span class="comment">//const引用</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total; <span class="comment">//学生总数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> BJUT_Student &amp; pb)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//输出信息用的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student stu1;</div><div class="line">    print (stu1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果print是一个用来输出学生对象中信息的函数，那这种方法(加friend)就相当于给了<code>print</code>函数一个特殊的权限。</p><p><code>friend</code>作用在<strong>类的成员函数</strong>时，用法也是一样的。</p><p>友元声明不写在<code>public</code>或<code>private</code>区域中。</p><p>总之，两个类之间需要共享数据的时候，可以使用友元。但请注意，友元实质上破坏了类的封装性。Java中就没有友元函数这一设定。</p><p>##2.数组作为函数参数，指针作为函数参数，与地址相关的运算『*』和『&amp;』</p><p>###2.1.数组作为函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * a)</span></span>;  <span class="comment">//声明方法1</span></div><div class="line"><span class="comment">//void sum(int [] a);   //声明方法2，这样也行</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">20</span>];  <span class="comment">//声明数组</span></div><div class="line">    sum (a);    <span class="comment">//传递这个数组为函数参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C语言里学过。形式大概就是上面这样。</p><p>###2.2指针作为函数参数，与地址相关的运算 <code>*</code> 和 <code>&amp;</code></p><p>C和C++语言中，同一个符号在不同的场合会有不同的意思。在和地址相关时：</p><ul><li><code>&amp;</code> ： 取址符</li><li><code>*</code> ： 取值符</li></ul><p>他们俩互为逆运算。<code>&amp;</code>就是取一个变量的地址（通常情况下，也就是指针的意思，但请不要认为地址==指针）。</p><p><code>*</code>的话就是“取一个地址内的值”，和上面的<code>&amp;</code>的操作正好相反。</p><p>就好比说，宿舍号“424”是一个地址，你取424的值，即<code>*424</code>，取出来的就是“王大水”这个值。如果你对“王大水”进行取址，即<code>&amp;王大水</code>，结果就是424.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> * p)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</div><div class="line">    <span class="keyword">int</span> * pointer1 = &amp;a;    <span class="comment">//将a的地址赋给指针pointer1</span></div><div class="line">    func(pointer1); <span class="comment">//指针作为函数参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> * p)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; p;      <span class="comment">//输出的是a的地址，即主函数中的&amp;a</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *p;     <span class="comment">//输出的是a的值，即233</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>##3.对象指针与动态内存分配</p><p>###3.1.对象指针</p><p>如果有一个指针<strong>指向了一个对象</strong>，那这个指针就是<strong>对象指针</strong>了。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    BJUT_Student * pb = student1;   <span class="comment">//pb指向了对象student1，pb的类型是"BJUT_Student"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###3.2.动态内存分配</p><p>咱们在C语言里学过<code>malloc</code>，写法比较繁琐，一般是</p><figure class="highlight plain"><figcaption><span>* BJUT_Student = (BJUT_Student*)malloc(sizeof(BJUT_Student));```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在C++里大幅简化了这个功能（申请内存），约等于</div><div class="line"></div><div class="line">```BJUT_Student * student1 = new BJUT_Student();</div></pre></td></tr></table></figure><p>方便多了吧。</p><p>在C++里，尽量使用<code>new</code>，尽量不使用属于C语言的函数(例如<code>malloc</code>)。</p><p>##4.派生类的构造函数和析构函数，复制构造函数，派生类成员的标识和与访问</p><p>###4.1.派生类的构造函数和析构函数</p><ul><li>构造函数：用来在新生成一个对象时初始化一些内容</li><li>析构函数：用来执行在销毁一个对象时要做的一些事情</li></ul><p>一般情况下，手写构造函数比较频繁，手写析构函数的机会不多。C++ Runtime 会自动为我们做一些事。</p><p>ps：构造函数在定义的时候，需要和<strong>类名相同</strong>。</p><p>派生类：即从已有的类继承而来的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A     <span class="comment">//基类A</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">int</span> x)&#123;</div><div class="line">        a = x;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    B(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : A(x)  <span class="comment">//派生类的构造函数，冒号后的是“初始化列表”</span></div><div class="line">    &#123;</div><div class="line">        b = y;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是这个意思，B继承自A。派生类的构造函数执行的时候，先执行父类的构造函数，也就是说<strong>初始化列表</strong>中的<code>: A(x)</code>.</p><p>析构函数也和类同名，但前面加了一个<code>~</code>，例如<code>~B(){//xxxxx}</code>。上述代码中没写析构函数。</p><p>派生类中的析构函数，执行的时候和构造函数的顺序相反，即先析构自己，再析构父类。<strong>除非</strong>父类的析构函数是虚函数(virtual)。</p><p>我还从来没实际用过析构函数，所以对这块不了解。一般情况下，对象销毁的时候，系统都自动为我们执行很多相当于析构函数的工作了。</p><p>关于“初始化列表”，可以简单的说：能用初始化列表的场合，都尽量使用初始化列表。尤其是，当某些const类型和引用类型的成员变量需要被初始化时，必须使用初始化列表，因为const或引用变量无法被复制（除初始化时）。</p><p>##4.2.复制构造函数</p><p>就我所知，一般在</p><ul><li>将对象作为参数传递，且为<strong>值传递</strong>的时候需要用到复制构造函数。</li><li>return一个对象。</li><li>纯粹复制一个对象。</li><li>构造一个对象时需要复制另外一个对象。</li></ul><p>说白了就是用来复制一个对象用的函数。关于值传递和地址传递的区别，可以参考我之前写过的文章。</p><p>复制构造函数的写法：一个<strong>参数为类的引用</strong>的构造函数，参数最好是const。例如：</p><p>复制构造函数在本质上还是构造函数，区别在于参数不同，用途不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B(<span class="keyword">const</span> B&amp;);    <span class="comment">//复制构造函数的声明</span></div><div class="line"></div><div class="line">B:B(<span class="keyword">const</span> B&amp; p)&#123; <span class="comment">//复制构造函数的定义</span></div><div class="line">    b = p.b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我的理解是：复制构造函数，就是一个明确指定“如何复制一个对象”的函数。</p><p>#4.3.派生类成员的标识与访问</p><p>不明白这是在说啥…</p><p>#5.虚基类</p><p>即在继承一个类的时候，在被继承的类名前面加个virtual。这在多继承时才会被用到。是为了消除二义性。</p><p>比如有基类A，B继承自A，C继承自A，又有D多继承自B和C。此时D中继承自A的成员，到底是哪一个A呢？（因为B和C分别复制了一份A的成员）这就产生了冲突。</p><p>如果在B和C继承A的时候，将A声明为<strong>虚基类</strong>即可解决这个问题，虚基类会确保A中的成员有且只有一份，D调用的时候就不会产生冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;     <span class="comment">//虚继承</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    A a;</div><div class="line">    B b;</div><div class="line">    C c;</div><div class="line"></div><div class="line">    a.i = <span class="number">1</span>;</div><div class="line">    a.print();</div><div class="line"></div><div class="line">    b.i = <span class="number">2</span>;</div><div class="line">    b.print();</div><div class="line"></div><div class="line">    c.i = <span class="number">3</span>;</div><div class="line">    c.print();</div><div class="line"></div><div class="line">    D d;</div><div class="line">    d.i = <span class="number">4</span>;    <span class="comment">//消除了二义性，如果不用虚继承，此处编译出错</span></div><div class="line">    d.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虚基类这事儿不常用。可以参考Java语言：根本就没有多继承，所以也不用操心这些事儿。</p><p>注：在Java中，和「多继承」类似的功能一般靠接口(interface)实现。</p><p>##6.单目和双目运算符重载</p><p>运算符重载是C++的一个特点，另一门面相对象语言即Java中，就没有运算符重载。因为他们的设计哲学有区别吧。</p><p>之前咱们学过函数的重载，即，当函数名相同，但函数参数列表不同时，程序会根据咱们实际所给的参数列表，动态地选择应调用的函数。</p><p>运算符重载也差不多，经过重载，同样地运算符在参与不同的数据类型（比如：int，double 就是两种不同的数据类型），会有不同的表现。</p><p>这是双目运算符的重载：(课本P310)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">Complex::<span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> Complex(<span class="keyword">this</span>.real + c2.real, <span class="keyword">this</span>.imag + c2.imag);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在双目运算符的重载中，运算符左边的操作数就是this。this一般可以省略。右操作数作为参数传递进来，也就是说这里的c2.</p><p>为什么需要重载这个加号呢？因为<code>Complex</code>类型是用户自定义的类型，C++编译器不知道该如何将两个这样的对象“加”在一起，需要用户手动描述。</p><p>单目运算符的重载也是一个意思。比较常用的单目运算符重载是<code>++</code>,<code>--</code>，值得注意的是，单目运算符重载一般没有参数（被运算的数作为this指针隐式传递）。</p><p>还有一种情况，即用友元函数进行运算符重载，这样的话，双目运算符重载就有两个参数，单目运算符重载就有一个参数。因为友元函数运算符重载没有this指针。</p><p>关于自增运算符前置、后置的重载，可以参考课本P312，非常清楚。</p><p>##7.多态程序编写，包括虚函数、纯虚函数以及抽象类</p><p>###7.1.多态，虚函数</p><p>什么是多态呢…</p><p>书上的定义不太好理解，一般都是类似于“对同一个消息作用在不同的对象上，会产生不同的效果”。你可能会问，这不是废话吗？比如有个父类Animal，子类Dog，我让Animal“吃”，和让Dog“吃”，效果肯定不一样啊，这还用系统给我判断？</p><p>你说的没什么错。按照我的理解，什么时候需要多态性呢？</p><p>比如有个<code>Animal</code>类型的指针<code>a</code>，这个指针<code>a</code>指向<code>Animal</code>的时候，你调用<code>a.eat()</code>。指针再指向<code>Dog</code>的时候，你又调用<code>a.eat()</code>。此时如果能分别正确调用<code>Animal</code>和<code>Dog</code>的<code>eat()</code>方法，那这就是多态。</p><p>如果你分别用指向<code>Animal</code>和指向<code>Dog</code>的指针，分别调用<code>eat()</code>，这就不叫多态。</p><p>多态这件事和<strong>继承</strong>是<strong>紧密相连</strong>的。</p><p>咱们应该是都学过Java了，为啥Java中没怎么提到过多态呢？确实如此，因为Java中的类的继承，在默认的情况下就已经实现了多态了。</p><p>但C++就没这么自动化，如果想让一个父类的某个成员函数能实现多态性，就必须规定这个函数为<code>虚函数</code>。</p><p>用刚才那个例子来说，也就是说得让Animal类中的eat()方法前加上一个virtual。类似：</p><figure class="highlight plain"><figcaption><span>void eat()&#123;//xxx&#125;;```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###7.2.纯虚函数</div><div class="line"></div><div class="line">纯虚函数是一种特殊的虚函数。即只声明，不实现定义。由继承下去的子类去具体实现。</div><div class="line"></div><div class="line">写法是这样：</div><div class="line"></div><div class="line">```virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</div></pre></td></tr></table></figure><p>加了一个<code>=0</code>。注意,<code>virtual</code>也不能少。</p><p>我个人理解：纯虚函数对应Java中的抽象(Abstract)函数。</p><p>###7.3.抽象类</p><p>只要是包含了纯虚函数的类就自动被归为抽象类。和Java中的抽象类类似，不能被实例化为对象，只能被继承。</p><p>抽象类中至少存在一个纯虚函数；存在纯虚函数的类一定是抽象类。存在纯虚函数是成为抽象类的充要条件。</p><h2 id="完毕。"><a href="#完毕。" class="headerlink" title="完毕。"></a>完毕。</h2><p>C++的确很有用，非常强大，效率很高。坦诚地讲，也很有学习的必要。但从我个人的角度，以及我目前对C++及其浅薄的认识，我不是很喜欢C++这门语言给我的感觉。强类型的面向对象语言中，我更喜欢Java。目前我正在(以极其缓慢、肉眼几乎难以辨别的速度)学习Python，如果有同感兴趣的朋友请一起来交流。</p><p>当然了，我想强调的是，我承认C++作为<strong>基石</strong>的作用。我也同意，作为计算机专业的学生，有必要对C++进行相对深度的学习。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/10/27/DC-regulated-power/" itemprop="url">直流稳压电源(电路实验1)笔记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-10-27T17:38:05+08:00" content="2015-10-27">2015-10-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>电子实验的第一个实验，「直流稳压电源」。由于实验小册子上的图和文字实在是太抽象、太魔性了，我把我对这个电路的一些认识写在这里，供参考。如果写错了内容并对你的电路(和心理)造成了不可逆转的伤害，我请你吃冰棍。</p><p>另外，我的器件包里没有任何<strong>电阻</strong>，但 @辛德龙 就有俩氪金彩色电阻，大家都有电阻吗？</p><p>#认识元器件</p><p>元件和器件是有区别的。在我看来，电阻、电容这类比较基础的东西就是「元件」，差分放大器、集成电路的话就算「器件」</p><p>##电解电容（大）<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/82966437.jpg" alt=""></p><p>1000μF</p><p>和整流桥并联。</p><p>给转换出的直流电做滤波(?)和稳压(?)用的，总之是个缓冲作用。这个电路上大多数的电容都是缓冲作用。</p><p><strong>听说这个电容接反的话会爆炸。</strong>，有白条的一侧就是负极。同时，引脚长的一侧为正极。</p><p>这个黑色电解电容，从包装来看是Rubycon牌子的，我上网查了一下，怀疑是假货。</p><p>##电解电容（小）</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/62548616.jpg" alt=""></p><p>数量若干。</p><p>##陶瓷电容</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26675224.jpg" alt=""></p><p>这种电容不用分正负。听说也不会爆炸？</p><p>##整流桥</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/24418714.jpg" alt=""></p><p>能将交流电转为（<em>不那么平整的</em>）直流电。大约是1V交流电（有效值）能转为1.2V直流电。</p><p>看印刷，<strong>两个「~」接交流电，「+」和「-」就是直流输出</strong>。</p><p>其实就是小册子上的这玩意：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/46572702.jpg" alt=""></p><p>因为这个整流桥的内部就是封装了4个二极管。</p><p>##二极管</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/73668153.jpg" alt=""></p><p>型号：1N4007</p><p><strong>有白环的一侧为负极</strong>。在咱们这个电路中，接在7805的1，3引脚之间，保护用。引脚3接二极管正极。</p><p>##稳压器</p><p>型号可能是「LM7805」</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/16602044.jpg" alt=""></p><p>从印刷字的一侧看，<strong>左起为引脚1，2，3</strong>。1接正极，3接输出，2接地。</p><p>由于经过整流桥整流过的直流电，还不是很平整（参考上面整流桥的波形图），这个7805就是撸平电流用的，作用类似电熨斗。</p><p>这个7805稳压器能稳定输出5V直流电源，输入的话一般在7-10V。那这几V的电去哪了？被这个器件变成热量了。上面的那个孔，就是接散热片用的。不过咱们这个电路电流不大，我估计不需要散热片。</p><p>##功率放大器</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/26540379.jpg" alt=""></p><blockquote><p>图：百度图片</p></blockquote><p>其实已经不是「直流稳压」部分的功能了。估计是为了驱动喇叭。</p><p>咱们给的是「386D」，和「LM386」的原理基本一样，应该是生产的厂商不一样。</p><p>有圆形凹陷的那个角，是引脚1（所有器件都这样）。引脚图：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/76078863.jpg" alt=""></p><blockquote><p>图：JRC的器件手册</p></blockquote><ul><li>引脚1，8：接一个电容，调节用</li><li>引脚2：反相输入（信号源）</li><li>引脚3：正相输入（信号源）</li><li>引脚4：接地</li><li>引脚5：输出信号</li><li>引脚6：电源（在咱们这个实验中就是7805给的5V直流）</li><li>引脚7：旁路（接一个电容，电容再接地。好像是对输出信号的稳定有好处）（去耦?）</li></ul><p>反相和正相输入，大概就是咱们电路课正在学的功率放大器吧。</p><p>##管脚座(?)</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/30867599.jpg" alt=""></p><p>386一定要插在管脚座上，将管脚座焊接在电路板上。我不确定是不是叫「管脚座」这个名字。</p><p>建议7805也接在座上，毕竟听说<em>电烙铁可能会焊坏器件（给的热量太多）</em></p><p>#电路图</p><p>小册子上的图太魔性了简直。</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-10-27/43741313.jpg" alt=""></p><p>感谢 @曾檬 @孙昀淏 分享图片，拯救我于水火之中。此图建议大家存好，你懂得。</p><p>#总之<br>想搞一个8Ω小喇叭，没搞来。</p><p>焊锡就给那么点，器件焊坏了还不给分，这真的是实验课？这让人怎么练手？非得让人缩手缩脚？一个器件有几块钱？我出钱买还不行吗？焊坏一个器件就不给分？</p><p>##接地是啥意思？</p><p>我理解接地，就是接「低电平」的意思，在咱们这个电路中，唯一可行的低电平就是电源负极。也就是说接地就是接电源负极的意思。</p><p>没必要接大地。</p><p>##一些笔记</p><ul><li>防止输入对地短路</li><li>防止输入输出接反</li><li>防止输入滤波电路短路（大概会爆炸？）</li><li>防止输出与高电平接（大概会烧坏器件）</li><li>防止三 - 地 - 开路 （原文如此，我也忘了记的是啥意思了，求解）</li></ul><p>##总之</p><p>这个电路：</p><ol><li>将交流电，用整流桥（扁平圆柱，四脚），变成不平整的直流电</li><li>将不平整的直流电，用稳压器（7805，三脚），变成平滑的5V直流电</li><li>用5V的直流电驱动功放（386D，八脚）</li></ol></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/26/programming-language/" itemprop="url">都有啥编程语言？</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-26T20:05:26+08:00" content="2015-09-26">2015-09-26</time></span></div></header><div class="post-body" itemprop="articleBody"><p>编程的语言多种多样，那么编程语言都有哪些呢？</p><p>本期栏目会根据2015年9月TIOBE的排行榜，对当下排名前20的编程语言做一个<em>非常简单</em>的阅览，以后再展开细说。对编程语言的介绍，由于王大水同学孤陋寡闻，难免存在错误，还请大家指出。</p><blockquote><p>TIOBE是一个编程语言的流行度排行榜，每月出一期。这个排行榜只能在一定程度上反映编程语言的流行程度，并不代表某种编程语言更好，没必要过度解读。</p></blockquote><p>#2015年9月排行<br><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-26/21170782.jpg" alt=""></p><p>其实也就前十左右还算是「主流」的编程语言。</p><p>#Java</p><p>Java语言很牛。近十多年来，Java基本上一直雄踞TIOBE榜首。</p><p>Java语言在刚面世的时候（1995年）心气非常大。Java想统一所有的平台，设计者的意思是，「有Java就足够了，其他编程语言都是渣渣」。虽然如今Java并没有这么万能，不过也是很厉害了。Java在企业后台开发、网页后端、Andriod开发、云计算、大数据等领域需求都很大。</p><p>Java是非常成熟的面向对象语言，Java宣称「Java语言中的一切都是”对象”」（虽然并不真正如此）。相比C++语言来说，Java是一个更加纯粹的面向对象语言。Java舍弃了很多『危险』的设计，比如指针、比如不让程序员手动操作内存。Java语言的安全性非常不错（相比C++和C），但在效率上就有所牺牲。</p><p>学Java的过程，相比学习C语言，是<em>非常</em>幸福的事情。</p><p>咱们计算机系的话，一般都是会学Java的。我的个人建议是，体会面向对象的初步思想，这是关键。要明白「继承」、「对象」、「类」这些概念的准确意思。因为任何面向对象语言中，这些东西都是想通的。至于Java语言的语法细节，或者Java的图形库等等细节的东西，不用抠太细了。</p><p>啰嗦一下，<strong>最好别用学文科的方法学编程。</strong></p><blockquote><p>名词解释</p><ul><li>Java SE。就是咱们平时学Java时所用的Java库的版本。如果大家有玩过「Minecraft」的话，应该还记得在运行MC之前必需安装Java，因为MC就是用Java编写的。你问为何Windows操作系统不自带Java？哈，他们两家公司的恩怨情仇回头还能细说。</li><li>Java EE。企业开发用的Java，不懂。</li><li>Java ME。M是Micro的意思，一般在单片机版之类的地方用，似乎已经没什么人在用了。</li></ul></blockquote><p>#C</p><p>就是咱们正在学的C语言。这算是老前辈了（1972）年，因为C既有「<em>高级</em>程序设计语言」的特点，又能操纵硬件层面的细节，所以很受程序员欢迎。</p><p>但是C语言是面向过程的语言，而且C语言中的「指针」「手动内存管理」等特性容易造成BUG，所以如今C语言用的已经不是太多了。但是毕竟是有用的，比如Linux(一种操作系统)大多数的代码由C语言构成。写单片机、数值计算领域，C语言还是用的很广泛的。</p><p>#C++<br>也是老牌面向对象语言了。我想出过一个比喻，我觉得用来形容C++语言还是挺恰当的。</p><p>「C++语言是一艘航空母舰，攻击力强大。但烧煤的发动机拖累了它。」</p><p>啥意思呢？C++语言在设计的时候，为了兼容C语言，便设计为「C语言的超集」，也就是说C++完全向下兼容C语言（从这门语言的名字也能看出来这一点）。这样一来，C++就背上了沉重的历史包袱。</p><p>比如为什么咱们能在「Visual C++」这个软件中编写C语言呢？就是这个意思。</p><p>#C井</p><p>「C#」，<strong>读做「C sharp」</strong>。就是「C 升号」的意思。（变相表达C”++“）</p><p>我猜测，如果读「C井」的话，只要读满65535次，有一定几率下辈子投胎M78星云。</p><p>C#是微软公司出品的一款编程语言，其实就是模仿Java整出来的一款竞品。C#我没接触过，听说很好用，很好学，很强大。很多桌面程序都是用C#写的。</p><p>说白了，你要是Java学得好，C#分分钟就会了。</p><p>#Python</p><p>Python可火了，啥都能干。Python语言相对优雅，相对速度还不错，相对易于学习。很多国外的大学，计算机专业的入门语言便是Python。听说国内有少数大学也在尝试用Python作为第一门编程语言。</p><p>数值计算、网站后端、脚本、还有今天特别火的大数据、机器学习啥的，Python好像都有份。</p><p>Python语言的特点之一是强制要求你使用规范的代码缩进。</p><p>#PHP</p><blockquote><p>「PHP」是世界上最好的编程语言。——PHP程序员</p></blockquote><p>PHP主要是在CGI（即网站后端）用途广泛，是一门非常经典的服务器后端语言。语法和C比较接近。</p><p>#JavaScript</p><blockquote><p>「Java」和「JavaScript」的关系，就如同雷锋和雷峰塔的关系。——知乎用户</p></blockquote><p>JavaScript的名字中为啥有个Java呢？可以这样简单理解：JavaScript的设计者抱Sun公司（开发Java的公司）大腿。</p><p>Javascript如今也是越来越火了，有前后端通吃的气势。</p><p>由于当初设计Javascript的人是个「Lisp」语言脑残粉，所以Javascript中的面向对象特性特别难用。但是毕竟人家已经成为了连接网站前后端的唯一语言了，几乎没有竞争对手。所以值得接触一下。</p><p>#Visual Basic .NET<br>名词解释</p><ul><li>Visual Basic，即VB。似乎很多人之前就接触过，就是拖一个个控件，然后就能做出个还算好看的程序。</li><li>.NET，我的理解是：微软的一整套东西，合在一起叫.NET。</li></ul><p>我觉得「Visual Basic .NET」就是咱们平时说的VB。</p><p>倒是一门不错的教学语言。我之前还真用Excel中的VB写了一个「生命游戏」，有兴趣请看我Github。</p><p>#Perl</p><p>没用过，似乎是一种处理字符串非常强大的语言。比如说，Perl内置了「正则表达式」，而正则表达式用来处理字符非常厉害。</p><p>似乎Perl和Linux/Unix结合使用的情况比较多。</p><p>这也是一门有年头的语言了，大概是20世纪80年代推出的。</p><p>#Objective-C</p><p>其实也挺老了，本来都快要退出历史舞台了，但正好Apple公司选了了Obj-C语言作为平台开发语言，所以又火了。</p><p>不过今天Apple公司也使用新的Swift语言了。不知道Objective-C何去何从。</p><p>#Assembly language</p><p>就是「汇编语言」的意思。</p><p>汇编语言是一种介于「机器语言」（01二进制代码）和「高级语言」（比如C语言）之间的一种语言。</p><p>恩…不知道什么人还在用。也许是写底层程序和驱动的吧。</p><p>#Ruby</p><p>如果说Ruby语言没有汇编语言流行，打死我也是不会信的。所以说这个排行榜看看就好。</p><p>Ruby是源自日本的一种编程语言，在网站开发方面非常流行。Github这个社区，最早就是Ruby程序员爱好者建立起来的。</p><p>#Delphi</p><p>听说这门语言在数据库方面用的比较多，「Dev-C++」这款软件也是用Delphi写的。</p><p>不过据我所知，Delphi已经基本退出历史舞台了。Delphi的前身是Pascal。</p><p>#Visual Basic</p><p>不知道这和Visual Basic .NET有啥区别。</p><p>#Pascal<br>想当年这也是挺火的语言。</p><p>我初中的时候，比如NOIP竞赛，Pascal和C语言还是并列的关系。他们都是经典的面向过程的语言。在我的指导老师上学的时候，Pascal是必修课，C语言是选修课。可见Pascal昔日的辉煌。</p><p>这门语言的名字是为了纪念数学家「帕斯卡」。帕斯卡发明了「加法器」，可谓是人类历史上的第一个「计算机器」。</p><p>也已经退出历史舞台了。</p><p>#Swift</p><p>Swift就是现在Apple公司力推的开发语言。Apple Store里的那些App，如今应该有好多已经是Swift写的了。</p><p>#MATLAB</p><p>一种主要用于数值计算的软件。但Matlab能干的事儿远不止数值计算，比如算法开发、数据可视化、数据分析、建模仿真等等，都能干。</p><p>更纯粹的数值计算软件是「Mathematica」，还有个同类的软件叫「Maple」。</p><p>#PL/SQL</p><p>PL/SQL是「过程化SQL」的意思，是「Oracle」（即甲骨文）公司独有的。如今Java语言的版权便归属于Oracle。</p><p>SQL是「结构化查询语言」的意思，在数据库中有非常广泛的应用。</p><p>#R</p><p>是一种统计领域中使用较多的语言。比如学经济/金融的同学，或者搞数学建模的同学，大概会接触到R语言吧。</p><p>#COBOL</p><p>这是一个20世纪60年代就有的语言。在企业/银行的数据管理中运用广泛。</p><p>#小结</p><p>有一种说法：一个好的计算机专业毕业生，应该掌握</p><ul><li>一门面向过程的语言</li><li>一门面向对象语言</li><li>一门脚本语言</li></ul><p>如果学有余力，最好</p><ul><li>对函数式语言有所了解</li></ul><p>打个比方，如果我毕业的时候熟悉C、Java和Python，对Scala有一定了解，就算是符合这个条件了。</p><hr><p>这个榜单一直排了50种编程语言。后边的语言，有些是应用的领域非常小，有些则是历史遗留产物了。</p><p>值得一提的是，排名第48的编程语言是「VHDL」，眼熟吗？</p><p>谢谢@刘鑫学长的提醒，数字逻辑这门课要学的是 Verilog HDL，和VHDL还是有些区别。不过他们能干的事儿都差不多。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/24/too-many-authentication-failures-error/" itemprop="url">ssh 连接时出现 too many authentication failures error</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-24T19:09:12+08:00" content="2015-09-24">2015-09-24</time></span></div></header><div class="post-body" itemprop="articleBody"><p>我在mac上，尝试用ssh连接我的ubuntu主机，但报错：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Received disconnect from x.x.x.x: Too many authentication failures for username</div></pre></td></tr></table></figure><p></p><p>我在<a href="http://theandystratton.com/2012/ssh-returns-too-many-authentication-failures-error-hostgator" target="_blank" rel="external">这个</a>网址找到了一个解决方案：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -o PubkeyAuthentication=no username@x.x.x.x</div></pre></td></tr></table></figure><p></p><p>就可以正常输入密码并登陆了。</p><p>似乎是<code>~/.ssh</code>中的密钥太多了，如果把这些密钥删除也能解决问题。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/18/c-learning-1/" itemprop="url">C语言学习札记(一)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-18T17:45:10+08:00" content="2015-09-18">2015-09-18</time></span></div></header><div class="post-body" itemprop="articleBody"><p>本期写一些初学者学C语言时可能会遇到的问题，为什么说是「可能遇到」呢？因为这些基本上都是我在学习的过程中遇到过的问题，曾经困扰过我。文章内容都是基础的内容，如果你觉得阅读起来有困难，可能是因为你还没学到那里。别着急，可以先收藏这篇文章，学习的过程中，想到这个问题时可再回来看看。</p><p>想到啥写啥。没时间列大纲了。</p><p>分享给各位学弟学妹一个建议：<strong>请以审辩的态度去听取他人的建议，包括我的这条建议。</strong>为什么呢？因为大家所走的路，和你将要走的路，尤其是你 <em>想</em> 要走的路，很可能相差甚远。别人的建议可能对你来说没有价值，甚至对你有负面的价值。比如说，会有人说「C语言的细节很多，不用搞明白那些细节」，也有人说「C语言不重要，你直接看面向对象语言就行」。这些意见自然多多益善，但对你最了解的还是你自己。</p><p>哈，上边出现了一个递归，你发现了吗？递归是咱们计算机科学中非常有意思的一件事，大家在学「函数」这章的时候，递归也是个不太容易理解的地方。不过大家可以放心，在C语言中，递归的方案完全可以转化为循环(while/for/do,for)的方案，除非在特殊的情况下，使用递归的场合不多。</p><p>一周下来四晚有课，心堵。</p><p>#如何向他人求助程序问题？</p><p>##搜索引擎是你最好的帮手</p><p>你所遇到的任何问题，有99.99%的几率，已经被别人遇到过了。在互联网上，有很多人在提问，也有很多热心的人在解答。将你的问题非口语化的描述，或报出的错误信息放在搜索引擎上查一查，一般问题都能得以解决。像是百度知道 / csdn和博客园的博客 / 知乎 之类的网站，存在着很多问题的解决方案。</p><p>如果总是查不到，可能是选取的关键词、或错误信息的提取不够准确。多查查就有感觉了。</p><p>##善用错误信息</p><p>如果程序存在语法问题，那么在编译的时候，VS会给你报个错。这些Error都是有描述性的信息的，大多数情况下，根据这些信息便可以修正程序错误。但往往错误信息是<em>英文的</em>，但都不复杂，很容易读懂。大不了把错误信息在百度上搜一下。</p><blockquote><p>Tips，如果错误信息在百度上查一无所获，去Google上试一试，往往有惊喜。</p></blockquote><p>但有些情况下，VS给你的错误信息让你觉得莫名其妙，完全驴唇不对马嘴。这种情况也是常见的，毕竟VS不是万能的。这种情况下，请参见下一个建议：</p><p>##再多读一遍<br>真的，这招太有用了。</p><ul><li>main → mian</li><li>true → ture</li><li>就算我按不序顺话说你能看也懂</li></ul><p>这种错误很容易犯，我现在写程序手一抖就打出个ture，然后还一点都看不出来。其实C语言还好，像是Javascript（大家以后可能会接触到）这样的『不那么严格的语言』，如果打错变量名，想找出错误来能把人累死。很多奇怪的问题都是由于细节的错误造成的，比如打错了字、少打了右大括号，打了不该打的分号，等等。如果问题就是特别奇怪，特别顽固，请试着再读一遍程序。</p><p>当然了，编译器能报错这件事，就已经令人感到非常幸福了。将来大家都会写大课设，到时候就会发现，绝大多数错误都是编译器报不出来的。尤其是一些「确实已经写错了的地方，但是C语言编译器以为你想故意这样hack一下」的错误，就不得不需要调试的手段了。现在大家除了F10逐行运行之外，还不需要太多调试的方法，但养成好的写代码习惯，比如命名、代码格式等等，还是请从现在做起。</p><p>#为什么能写C语言的程序有那么多？<br>你可能会发现，大家用于学习C语言的软件都不太一样。在机房，老师可能为大家展示VC6.0；你的同学中，有些人用Code::Blocks，有些人用着迷离的高端程序，你可能正在用VS2015.</p><p>它们有什么区别？区别不大。它们都被称作「IDE」，都能写C语言。只是各种附加的工具不同。想详细了解「IDE」，可翻阅本公众号的往期文章。</p><p>请注意：C语言不是程序，C语言只是一种『编程语言』。所以说用哪种「IDE」去学习，都是无关紧要的。我个人推荐大家使用VS。</p><blockquote><p>其实VS和其他的IDE还是有些区别，这些区别有时能能影响到大家。有时候，可能你同学写好的、能够完美运行的代码，完整复制到你的电脑上，却运行不正常，甚至没法编译。因为VS的「编译器」和其他的IDE多少有些不一样。甚至VS和VC也不一样。「编译器」决定了IDE如何去处理代码，而不同的编译器的处理方法有所不同。那应该怎么办？尽量使你的代码写的规范，就能大大避免这种问题。下面有相关的问题会提到。</p></blockquote><p>#注意 = 和 ==<br>在C语言中，</p><ul><li>= 叫做 赋值号</li><li>== 叫做 等于判断符</li></ul><p>这事儿是个大坑，基本每个人都得栽里边儿，我就栽在里面很多很多次。</p><p>比如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (a = 1)</div></pre></td></tr></table></figure><p></p><p>这种语句，你的意思可能是如果a等于1，就怎么样。但在这里，会把 1 赋值给 a。关键在于，这种问题程序是不报错的。那为什么程序不报错呢？因为(a = 1)理论上可作为一个表达式，这个表达式也是可以表达值的。</p><p>听说有些编译器会对这种情况报一个 Warning，因为这种错误实在是太常见了，专业的程序员也有时中招。</p><blockquote><p>理论上的建议是，不将『左值』作为变量名，也就是说只写(1 == a)而不是(a == 1)，因为这样的话就算是不小心少打了一个=，编译器就会报错。因为常数1不能被赋值。</p></blockquote><p>#到底是 void main 还是 int main ?<br>大家已经学习到了，C语言中最核心的函数是「主函数」，主函数就是形如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">	xxxxxx....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这样的函数。大家可能会注意到，在有些课件和书上的示例中，写的是<code>void main</code>，那到底哪个对？</p><p>先给结论：<strong>只写</strong><code>int main</code></p><p>int main 是目前最为规范的写法。C语言自诞生以来，并不是一成不变的。有些特性被淘汰、有些被更新、还有些新的特性加入，所以可以这样理解，void main 是一种历史遗留的写法，已经不用了。那为什么书上和课件上还有呢？大家可以注意观察下，有些课件的年龄已经10+了。或者说，咱们的老师学这门语言的时候，规范和今天并不一样。</p><p>#主函数最后的 return 0 是什么意思？<br>其实这个<code>return 0</code>是可以不写的。如果不写的话，相当于「编译器」自动帮我们加上这行。return 0如果写的话，必须写在主函数的最后一行写。如果return 0后边还有语句，就不会被执行。</p><p>大家观察<code>int main(){}</code>最前面的<code>int</code>。可能大家还没有学到「函数」，这里为大家介绍一下，C语言中的「函数」(function)和数学里的函数可以类比理解，即「给这个函数参数」，然后「函数返回给你结果」。所以在C语言中，函数名前面的「类型」就指的是「函数返回值的类型」。</p><ul><li>int add(1,2){ … } ， 表示 add 这个函数的返回值的类型是整型(整数)</li><li>void run(){ … } , 表示 run 这个函数没有返回值(void 差不多是「nothing」的意思)</li></ul><p>那么，int main 的意思就是，<strong>主函数的返回值类型是整型</strong>。</p><p>你也许会问，既然C语言中函数的返回值是给用户看的，那为什么主函数也有一个「返回值」呢？答案是这样的：对于普通的函数来说，调用他们的人是「主函数」，也就是说他们的返回值会返回给「主函数」。那么主函数是谁调用呢？是「操作系统」调用主函数。比如你的电脑是Windows 7，那么就是Windows 7 调用了这个主函数。</p><p>那为什么需要返回值？当一个主函数返回一个「0」给操作系统时，操作系统就知道这个函数的运行结果「正常的」，也就是这个函数正常地运行完毕了。这就是 return 0 的意义。</p><hr><p>今天就发这几个吧。如果大家有任何问题，欢迎后台来留言或直接跟我聊。我保证，如果我不知道答案、也在网上查不到资料的话，我会说不知道，保证不跟你胡诌。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/15/Mountain/" itemprop="url">Mountain</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-15T12:29:54+08:00" content="2015-09-15">2015-09-15</time></span></div></header><div class="post-body" itemprop="articleBody"><p>山</p><p>不动的山</p><p>风雨来嬉戏，山变矮了</p><p>岩浆躁动着，山又变高了</p><p>一颗颗的树，根扎进了大山</p><p>一朵朵的云，欢快地飞过山尖</p><p>云会不会想</p><p>这是大山和我相距最近的时刻</p><p>再靠近我一点儿好不好?</p><hr><p>阳光载着低熵，将秩序赐予万物</p><p>阳光！你就是神，你就是意义，你就是存在</p><p>山脉为你隆起</p><p>川河为你流淌</p><p>物质说，我是能量的仆人</p><p>能量说，信息统领我的意志</p><p>数不尽的故事在山中传说</p><p>你可还记得于孤山之上展翅而飞的巨龙?</p><p>万事起，万事终</p><p>信息辗转沉浮</p><p>如是而已</p><hr><p>你注视着苍翠的大山，笼罩着迷雾</p><p>你似是听到了远方传来的上古传说</p><p>你抑制不住好奇之心，对那山问</p><p>你认得我们吗？</p><p>回答你：</p><p>不</p><p>我是大地的子民</p><p>我是阳光的孩子</p><p>我是时间的使者</p><p>我是那座山</p><p>不动的山</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/10/原、反、补码学习笔记/" itemprop="url">数制，原反补码，浮点数学习笔记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-10T14:30:58+08:00" content="2015-09-10">2015-09-10</time></span></div></header><div class="post-body" itemprop="articleBody"><p>其实也不是笔记，我上课从来不记笔记，呃，懒。</p><p>结合参考资料，写一写我对这几天学习内容的想法。大家可选择性阅读。</p><p>有些东西是上课没说到的。</p><p>##010101</p><p>先从二进制说起。</p><p>####为什么计算机需要用二进制存储数据？</p><p>二进制中只有「0」和「1」。</p><p>计算机是通电的，那么在电的世界中，</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-10/72692184.jpg" alt=""></p><p>没通电的的就是「0」，通电的就是「1」。</p><p>为什么是二进制呢？因为这种「无」和「有」的二元对立关系，是非常好实现的。试想，如果要造一个「十进制计算机」，那就要创造出一种能够表达10种状态的东西，还得能够对这10种状态进行准确的观察、计算，难度很大。「电」的特性正好满足二进制的需求。「高电平」就是1，「低电平」就是0。</p><p>你可能会问了，那电压有大有小的，为啥就只有0和1，不会出个0.5呢？</p><p>如果是计科的同学，咱们这学期在同时学的两门课「数电」（数字逻辑）和「模电」（电路设计），就和这相关。数电是抽象，把电路抽象成0和1，关注其中的逻辑部分，性质是离散的。而模电就是研究具体的电路，和实际世界关系紧密，性质是连续的。</p><p>如果说这是数字电路的话：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-10/88810670.jpg" alt=""></p><p>那这就是模拟电路：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-10/92889196.jpg" alt=""></p><p>##进制</p><p>一张很有意思的漫画：</p><p><img src="http://7xku3h.com1.z0.glb.clouddn.com/15-9-10/27697363.jpg" alt=""></p><p>收藏多年。很有意思。</p><p>人类之所以用十进制，很可能跟人类长了10跟手指头有关系。在计算机中，2进制-8进制-16进制的互换是很方便的。可以想象，如果人类进化出8根手指头，学习计算机的难度大概会大大降低。或者说，人类长了<code>2^n,n∈k</code>跟手指头。哈。</p><p>##为什么课本上的原码、反码和补码都是8位？<br>在计算机中，一位0或者1叫做一个<code>比特</code>，8个比特可组成一个<code>字节</code>。所以8位是很常用的。在C语言中，int型占用4个字节，也就是32位。double型占用8个字节，即64位。</p><p>书上都写成八位，大概是为了方便吧，毕竟8位的用途很广，最早的CPU也是8位的。课本上没说理由。</p><p>另外，不论是原、反、补码，最高位（最左边那位）都是符号位，1是负数，0是正数。也就是说具体的数值的部分，只能靠7位比特来实现。</p><p>##原、反、补码<br>大家在刚学C语言的时候，大概都会遇到一个现象，就是<code>溢出</code></p><p>比如我有<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int n = 2147483647;</div></pre></td></tr></table></figure><p></p><p>这是int型能表达的最大值，这时我<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n++; printf(n);</div></pre></td></tr></table></figure><p></p><p>这时候n显示的值是<code>-2147483648</code></p><p><strong>从最大值变成了最小值！</strong>发生了什么呢，从课堂上的内容就很好理解，因为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">01111111111111111111111111111111 + 1 =</div></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10000000000000000000000000000000</div></pre></td></tr></table></figure><p>最前面的1意味着这是一个负数。</p><p><em>到现在我也没太想清楚，一个范围内最小的这个数，补码是怎样被处理的。求指点。</em></p><hr><p>这里假定大家对原码、反码和补码的特征已经掌握了，那咱们来分别分析一下。</p><p>###原码</p><p>原码的最高位是符号位。其他位数表示数值。</p><p>在课上，咱们了解到原码有个缺点是<code>同时有+0和-0</code>，其实这还不是什么严重的问题。毕竟<code>-0</code>在计算机中是有用的，后面说到。</p><p>“绝对值相等的正数和负数”相加应该是<code>0</code>，但是在原码中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1+(-1) 即 0001 + 1001 = 1010</div></pre></td></tr></table></figure><p></p><p><code>1010</code>在原码中明显是<code>-2</code>. 正1和负1相加，得负2.</p><blockquote><p>坑爹啊，原码根本没法用。</p></blockquote><p>###反码</p><p>为了保证正负数相加得0，便采用了反码。</p><p>比如在四位的反码中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">7 + 1 即 0111 + 0001 = 1000</div></pre></td></tr></table></figure><p></p><p>即<code>7 + 1 = -7</code></p><p>此时反码就已经有了”<em>表示范围内的最大的数+1，等于表示范围内的最小的数</em>“这一特征。(即溢出)</p><p>反码巧妙地解决了原码正负数相加不得零的问题。但是还有个遗留问题，就是<strong>仍然有正负两个0</strong>。</p><p>其实负0在某些情况下是有用的，在<code>Javascript</code>语言中就有负0.有时候，当一个负数特别特别接近零，以至于精度都不足以将它显示出来时，就表示为-0.以便和真正的0区分开来。</p><p>###补码<br>补码就是为了解决正负两个0的问题。</p><p>通俗来讲，补码就是在反码的基础上，把所有负数的表示范围减小了一格。例如原来能表示<code>-7 ~ -0</code>，现在就能表示<code>-8 ~ -1</code>，-0自然就没有了。</p><p>补码在”绝对值相等的正负数相加”这件事儿上，一定会产生一个<code>进位</code>，把<code>进位</code>舍弃后，结果即为0.</p><p>现在正1加负1就得0了，正确。</p><p>###溢出<br>溢出的本质现在就明白了。正是因为数字在计算机中全部以补码表示，而补码的特点就是会溢出。</p><p>其实别的语言还好，但C语言的设计思路就是「充分信任程序员」，所以C语言假定你很清楚「int型的最大值是2147483647」。呵呵。</p><p>##再论补码</p><p>理论上，补码的学名是<code>2的补码</code>或<code>2的补数</code>，即「Two’s Complement」.</p><p>重温一下，补码的转换方式是</p><ol><li>各位取反</li><li>加1</li></ol><p>其实对于计算机来说，采用什么码都可以，比如咱们今天上课讲到「BCD码」，BCD码中竟然就有「8421码」、「2421码」、「余3码」等等等等种类。只要能在数字和编码之间，形成一一对应的关系即可。但不同种类的编码自然有不同的特点。为什么补码用来表示计算机中的一切数字呢？</p><p>根据查到的资料来看，补码的优点之一是：<strong>如果使用补码，那么所有的加法都可以用一种电路完成。</strong></p><p>老师在课上提到，在计算机中，减法会被归约为加法。比如</p><p>$$<br>5 - 3 → 5 + (-3)<br>$$</p><p>而原码就没法做这种规约，如果使用原码的话，加法是一套电路（加法器），还需要专门实现一套「减法器」。</p><p>##定点数和浮点数<br>似乎课上对于这两样东西只是一带而过，这里简单提一提。</p><p>定点数：小数点是固定的(即位置是默认的)。比如说银行存款的系统，就适合用定点数来表示，因为存款的话，需要在计算机中储存的数字，都是只有小数点后两位（100,000.00￥）。定点数中，小数点的位置是由硬件/软件固定好的。</p><p>浮点数：就是咱们在计算机中常用的用来储存小数的方法。float和double都算是浮点数。</p><p>咱们学过科学计数法。浮点数的实现依托于科学计数法。咱们来分析一下<code>double型</code>。</p><p>double的学名是<code>双精度浮点数</code>。前面提到，double型占用8个字节，即64位。那这64位都是干啥的呢？</p><p>位数的分配如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = 1 位符号位 | e = 11 位指数位 | f = 52位有效数字</div></pre></td></tr></table></figure><p>它形如<br>$$<br>(-1)^s*1.f*2^{e-1023}<br>$$</p><p>为什么最左边是-1的s次方呢？因为<code>s=0</code>的话，该数就是正数，如果s = 1的话，改数就是负数。<strong>这就是「最高位符号位」的实现原理</strong>。巧妙吧。</p><p>那个1023是偏移量，跟无符号数转为有符号数有关(即把一半的表示范围分给负数部分)。</p><p>细节就略过了，反正我也不懂。符号位即是管正负的。指数为决定了小数点的位置，所以叫<strong>浮点数</strong>。就好比是科学计数法中，e后边的数字。表示这个纯小数乘10的多少次方。每乘一个10，小数点向左浮动一位。反之亦然。</p><p>大家知道，电脑中有两个重要的部件，分别是「CPU」和「GPU」。GPU也即显卡的核心芯片。那为什么GPU用来运算图形就特别快，而CPU就无法胜任呢？因为<strong>GPU是专门用来计算浮点数的</strong>。而计算机要想显示出图形来，就需要运算大量的浮点数。为啥GPU算浮点数就快呢？大概跟硬件层面上的设计和指令集有关系吧，毕竟术业有专攻。</p><p>现在挖比特币，超级计算机阵列等等，都大量使用GPU，因为这些任务都对浮点数的运算有高要求。</p><p>##拓展阅读：</p><p>说一下浮点数的形式中的<code>f</code>和<code>e</code>。</p><p>在<code>Javascript</code>这门语言中，根本就没有整数，一切数字都是用浮点数表示的。在Javascript中，除了普通的数字，还有NaN，+Infinity，-Infinity。</p><p>参考上方的「double型浮点数的形式」，在Javascript中有如下处理：</p><ul><li>当 e = 0 且 f = 0 时，该数为0；</li><li>当 e = 255 且 f = 0 时，该数为±Infinity(正负无穷)，具体的正负值由s决定。</li><li>当 e = 255 且 f ≠ 0 时，该数位NaN(Not a Number)。即「不是一个数」。比如除数为0时，结果就是NaN。</li></ul><p>计算机的电路很原始的，大概只能算算加法，做做位运算。什么乘啊除啊都没法直接做，更遑论那些函数啥的了。但计算机毕竟是离散的，而且也是不嫌烦的。比如说要计算正弦函数，对<code>Sin(x)</code>进行泰勒展开，有<br>$$<br>sin(x)=x-x^3/3!+x^5/5!-x^7/7!+……<br>$$<br>大约只需要展开六七项，精度就可以满足double类型的精度了。</p><p>别问我泰勒展开是啥，我不会（泪目）。大一的同学们，且听我一言：</p><p><strong>请一定要好好学高等数学。和一切数学。</strong></p><hr><blockquote><p>参考资料</p><p>〔1〕赵岩 . C语言点滴 . 人民邮电出版社, P58</p><p>〔2〕Charles Petzold . CODE . 电子工业出版社, P365</p><p>〔3〕贾熹滨等 . 数字逻辑基础与Verilog硬件描述语言 . 清华大学出版社, P9</p></blockquote></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/09/programming-guide-for-freshman-3/" itemprop="url">计算机专业新生指南(之三)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-09T16:35:26+08:00" content="2015-09-09">2015-09-09</time></span></div></header><div class="post-body" itemprop="articleBody"><p>咱们上回说到了编程用的IDE，以及推荐VS2015的理由。</p><p>今日话题：</p><ul><li>计算机专业到底学啥？</li></ul><p>我也不是毕业多年的老专家，只是普通的学生之一，所以对「计算机专业学什么」这一问题，也只能是管中窥豹，如果有说的不妥当的，还请多见谅。我写出的是我一年的学习过程中思考的产物，没经历过的事情我就不瞎扯了。</p><p>##计算机专业的课程</p><p>「培养方案」是个挺有意思的东西，一般作为一张Excel表格存在。辅导员会发给大家。</p><p>这张「培养方案」列出了你大学四年需要上什么课，以及课的学分、性质、学分等等。如果想搞明白这门专业到底学啥，有个很简单的方法——把每一门课都在百度查一遍。也可以通过观察课程的学分多少，大致揣摩不同课程的重要程度。</p><p>计算机院同学今年的新同学们，如果是「计算机类」的话，也许没有完整四年的培养方案，不过和之前的培养方案都大同小异，虽然你们的总学时减少了，但计算机专业的核心课程是不会变的。可以找往年计算机科学与技术、信息安全或物联网专业的培养方案作为参考。</p><p>大家不用着急，虽然咱们都是计算机专业的学生，但专业的「核心课程」在大二下、大三上才开始密集展开，前一年半，学的都是些基础课程。我将这些基础性课程分类三类：</p><ul><li>通识的</li><li>偏数学的</li><li>偏计算机的</li></ul><p>####通识的<br>什么是通识课呢？英语、体育等。</p><p>英语建议好好学，请稳住英语水平过快下降的势头（三阶导数，233）。从功利的角度讲，早过四级没啥坏处。对于计算机专业，英语阅读能力也很重要。大一也许还不觉得，但当你深入专业的学习时，许多信息、资料都以英文形式存在、计算机上很多软件对中文的支持比较渣、在某种软件的官方查文档时也都是英文。</p><p>英语不用担心，我觉得有意识地稍微背背单词就好，保持对英语还算有点感觉。</p><p>关于体育，一本书的名字说明一切：《程序员健康指南》。各大网上书店有卖。</p><p>####偏数学的<br>作为一枚纯学渣，我本是没有资格讨论数学课的…权当我发出学渣的呼声吧。</p><p>我不清楚你们还学不学「线性代数」了，当时我们学线性代数，整个人都不太好了。正巧赶上我们那位老师，对我们清不清楚线性代数和计算机专业有什么关系一点也不在乎，第一节课撸起袖子就开始讲“行列式”了。所以我们都是在迷茫中度过的线性代数的学习。</p><p><strong>线性代数放在大一上学期很不合理。</strong>对计算机专业来说，这其实是一门重要的数学。别的我不清楚，只说在计算机图形学领域，满地都是线性代数。什么是图形学呢？比如如果大家对做游戏感兴趣的话，那就得和图形学打交道。</p><p>其实，每一门数学课都有它存在的意义，哪怕是无法直接应用在计算机专业中。比如「高等数学」，从功利的角度讲，学好微积分，对你的「大学物理」大有裨益。从情怀的角度讲，「高数」训练你的数学思维和能力，灵活咱们的大脑，好让咱们对将来复杂度更高的知识结构学起来更加轻松。【以上这段文字不代表个人内心的真实观点】</p><p>「离散数学」更是计算机专业的根基。我很感谢我们这学期的各门课程的老师，都对本门课程和计算机专业的关系进行了一定篇幅的介绍。</p><p>说句官话：这些数学课程所培养的抽象思维能力，决定了你在计算机专业学习者的队伍中的位次。某大青鸟这些机构，每年也能培养出许多许多的程序员。那你也许会问，既然他们出来就能拿万八千的工资，那我为何还要在大学读计算机呢？区别就在于基础性质的知识有无。这些知识也许我们终将遗忘，但思考的方式和习惯却能<strong>内化</strong>到我们的大脑中。那些培训班出来的人，所掌握的技能都是空中楼阁，一旦技术改朝换代，他们就将被替代。但技术无论怎样更迭，其核心的脉络都是不变的。在（核心知识的稳定性）这点上，大概计算机科学和其他任何理工科学科都差不多。</p><p>数学，如果你喜欢，那真是莫大的幸福。如果你不喜欢，也请好好做作业。事实证明，只要作业都做了，多多少少也能受到一定程度的训练。如果是完全凭期末突击的话，甚是可惜，这门课就真的是浪费掉了。如果某人脑袋还没那么灵，说不定就挂科了。</p><p>有句老话：学习数学和计算机专业的基础课程，就像是在修炼「内功」，内功强大了，什么招式学的都快，理解得也透彻。好比开车，谁也没要求开车上路的人一定要知道发动机、离合器等东西是怎样一回事，但是如果略对其原理有所了解，一定能更好地驾驭汽车。</p><p>[唉]，一声叹息。我一定要好好学数学【严肃脸】。</p><p>####偏计算机的<br>大一比如有C语言，C语言课程设计，Java语言；到了大二还有数电、数据结构与算法之类的。</p><p>简而言之，如果你用心学这些课，那自然会迈入一个更加广阔的世界。</p><p>如果你对这些课程没感觉，甚至抵触，也请一定要跟好进度。一种经常发生的情况是：遇到一个大的挫折，反复折腾也弄不好，于是就放弃了对这门课的学期热情。这很常见。请多跟身边的学霸交流，报好学霸大腿，暂且不论平时能有什么收获，到了期末也能让你好过很多。</p><p>学习编程的建议在系列之一已经提到过了，如果只强调两条，我想说的是</p><ul><li>多敲代码</li><li>多想</li></ul><p>把书上的代码手动打到键盘上，是学习编程的好方法。</p><p>C语言中有些东西比较抽象，比如「二维数组」（不重要），「指针」（重要）等。平时没事儿了多想想，慢慢地就理清楚了，如果只靠每周上课的那几个小时，也许会想不清楚。</p><p>另外还有个事儿，就是很多对计算机感兴趣的同学，很早就会接触到技术上的东西，能做出个软件/网页/游戏啥的。如果你是这样的人，那恭喜你。在我看来，能用计算机去创造什么东西的人，一定是享受这个过程的。如果你不是，看到了你身边的大神同学，请也别慌张，毕竟大家时间上的分配是不同的。咱们在大学里，时间相当充裕，用来学基础课的时间很多，不着急，闻道有先后而已。最低标准是跟紧课程标准，在搞定培养方案的要求后，再用自己的余力去探索计算机的世界。看书也好，做东西也好，都是收获。</p><hr><p>另外提一个有意思的事儿，计算机专业之所以能作为一个「专业」，其理论依据是ACM和IEEE/CS共同推出的《计算作为一门学科》的报告。其对「计算学科」的定义是：</p><blockquote><p>计算学科是对描述和变换信息的算法过程的系统研究，包括它的理论、分析、设计、有效性、实现和应用。</p></blockquote><p>虽然「计算学科」和「计算机专业」还是有所区别，毕竟咱们学习的内容中「工程」的东西更多一些，但是这个定义还是挺有意思的，大家感受下。</p><p>在咱们计算机院，不管是哪个专业，其核心的课程都可以用「计算机科学与技术」中的课程作为代表。「科学」就是科学的意思，「技术」可以类比工程。还有一句话也挺有意思：</p><blockquote><p>科学家研究已有的世界，工程师创造未来的世界。</p></blockquote><hr><p>题外话。另外我想说，学习计算机专业，并不意味着你就要成为「计算机科学家」、「IT从业者」、「码农」等等。学习计算机专业，就像很多其他专业一样，同样是一种手段，目的是让你感受美、幸福与平静。退一步讲，这也是我们生活在这发达的文明社会中的一种意义之一。然而有些理想是那么遥远，那本来是你的梦，然而当你反复跟别人讲述这梦时，你却慢慢遗忘了梦的本身，最终只记住了你对梦的描述。也没关系，「不忘初心」这句话对于我们来说不太适用，毕竟到了大学，三观难免一天一变呢。共勉吧，亲爱的朋友，祝我们学习顺利。</p><p>是以为系列之三。</p><p>下期咱们聊「如果我不喜欢计算机专业该怎么办？」</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="//schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2015/09/07/programming-guide-for-freshman-2/" itemprop="url">计算机专业新生指南(之二)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2015-09-07T19:43:01+08:00" content="2015-09-07">2015-09-07</time></span></div></header><div class="post-body" itemprop="articleBody"><p>大家也都听说过了，计算机专业需要用到电脑，主要的需求就是「编程」。上期中，我们聊了聊编程大概是怎样一回事，给出了一些学习C语言的建议。</p><p>这期我们来说说「编程」这一活动需要用到的软件。</p><p>##先给结论<br>推荐：<strong>Visual Studio 2015 Community</strong></p><p>原因后面细说。如果不想看文字，只想要适合学习编程的软件，去下载这个就好。百度即可。</p><p>如果您有其他推荐，欢迎来探讨。</p><p>##什么是编程用的软件？<br>上期文章提到，不同的编程语言就像是不同种类的工具。对于一个工匠来说，他有了工具还不够，还需要有一个用于工作的「工作台」。此时，「工作台」这个概念就有点像「进行编程需要用到的软件」，或叫做「编程工具」。</p><p>编程用的软件，就像工具台一样，给你提供了一个平台，提供了写代码的白纸、帮助你查代码错误的工具、把你写好的代码翻译成机器语言的工具，等等。对于我们这些学习者来说，想要学习编程，就需要用到「编程用的软件」。</p><p>在咱们这个专业，「编程用的软件」有个专业名词，叫「集成开发环境」，英文简写「IDE」。大家今后再说任何编程软件，叫他「IDE」就好。读音「爱-地-意」。</p><p>本期介绍的软件都主要运行在Windows系统上。如果有买Mac的同学——相信以你的觉悟水平，也不需要看本篇文章了。顺带一提，Xcode是OS X系统上非常好用的IDE。</p><p>##都有什么种类的「IDE」？</p><p>大家在第一次上机时，老师也许会为大家讲解相关知识，但根据学长们的回忆，老师讲的也许不甚详细。大家稀里糊涂的，慢慢就明白了。大家读这系列的文章时，也许也会觉得不明觉厉，但随着你学习的深入，慢慢都会豁然开朗。希望这些文字，能对你打地基的过程提供些许微薄的帮助。</p><p>在上机时，机房中所安装的「IDE」，也基本上就是C语言编程常用的「IDE」。例如：</p><ul><li>VC6.0</li><li>VS2010</li><li>Dev-C++</li><li>Code::Blocks</li></ul><p>下面对他们做个简单的介绍。</p><p>####VC6.0<br><em>很可能</em>是老师演示时用的IDE。全称是Visual C++ 6.0。这是微软公司的一款软件，是一度非常流行的C语言和C++语言的开发平台。</p><blockquote><p>大家可能会感到疑惑，这软件的名字里明明有个「C++」，为什么用来学习C语言呢？原因如下：从历史来看，是先有C语言，再有的C++语言。C++语言是以C语言为核心的一种编程语言（从名字也能看出来）。C++在设计时，完全「向下兼容」C语言。意思是，C语言的一切东西，都包含在C++中了。所以在任意C++语言的开发平台，都可以学习/开发C语言。用比较学究的话说，C++是C语言的「超集」（类比「子集」）。</p></blockquote><p><strong>不太推荐使用VC6.0。</strong>因为这款软件已经很老了，恐怕只有大学的计算机系中才安装着这么多VC6.0。为什么呢？因为计算机这个学科的技术更迭是很快速的，一种软件可能几年时间、甚至几个月时间就过时了，但大学中的知识也好，还是机房中的软件也好，更新速度都是较慢的。</p><p>还有一个原因，就是老师教课可能都教很多年了，他已经习惯于用VC6.0.</p><p>##VS2010<br>VS2012的全称是「Visual Studio 2010」，其实这是一个大大大大工具包，里面的内容包罗万象，其中有一个部分，叫做「Visual C++ 2010」。从名字可以看出，这是VC6.0的后续版本。但我们出于习惯，都把VC6.0之后的版本叫做VS。例如VS2008、VS2012、VS2015.知行楼的机房一般安装的是VS2010.</p><p>我推荐的版本是VS2015 Community。为什么？</p><ul><li>好用</li><li>免费</li></ul><p>好用是真的。VS系列可能是Windows平台上，乃至C++开发的最佳IDE。对于我们这些学习者来说，VS的「调试功能」是非常好使的。对于「调试」，今天不做展开，但大家将来要做「C语言课程设计」，如果没有好用的调试手段，那将是非常痛苦的。</p><p>为什么说免费？「Community」意味着这是一个「社区版」，面向给学生、个人开发者免费使用。既然是免费，那么功能肯定有所精简，但对于我们这些学习者来说也是绰绰有余了。VS的旗舰版本是「Ultimate」，如果要买的话，恐怕得好几千<em>美元</em>吧。</p><blockquote><p>网上的破解版当然很多，但是在力所能及的情况下，我还是推荐大家使用正版（免费的Community版本就属于正版）。毕竟大家学的是计算机，将来说不定就进了计算机行业。我相信人品守恒、因果报应。当然，我的电脑里也正用着盗版软件，活了这么大也用了无数盗版的软件和游戏，我希望在将来，只要是我的财力允许，我会尽量去使用正版软件。我大力支持开源软件，但同时我也认为商业的软件应当受到法律的保护。</p></blockquote><p>其实工大也为我们购买了正版授权，在ca.bjut.edu.cn可下载(内网)。</p><p>##Dev-C++<br>编程竞赛中经常用到的软件。用起来挺方便，但是调试功能很弱，稳定性也不好。不推荐学习时长期使用。</p><p>##Code::Blocks<br>和Dev-C++类似，但比前者功能更多。但(通常情况下)他们的编译器都是gcc.所以对于我们学生来说差不多。如果感兴趣的话，不妨安装一个作为备用。</p><p>##VS2015的具体使用方法和参考教材<br>下期见。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person"><img class="site-author-image" itemprop="image" src="http://7xku3h.com1.z0.glb.clouddn.com/alanwang.png" alt="Alan"><p class="site-author-name" itemprop="name">Alan</p><p class="site-description motion-element" itemprop="description">Alan Wang's personal blog.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">63</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://www.null17.com/" target="_blank" title="十七的空指针"><i class="fa fa-fw fa-globe"></i> 十七的空指针 </a></span><span class="links-of-author-item"><a href="http://iaside.com/" target="_blank" title="马文瑞的博客"><i class="fa fa-fw fa-globe"></i> 马文瑞的博客</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Alan</span></div><div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script></body></html>